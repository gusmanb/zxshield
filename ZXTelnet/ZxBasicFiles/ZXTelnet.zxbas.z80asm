	.zxbasic
	org 32768
	; Defines HEAP SIZE
ZXBASIC_HEAP_SIZE EQU 4096
__START_PROGRAM:
	di
	push ix
	push iy
	exx
	push hl
	exx
	ld hl, 0
	add hl, sp
	ld (__CALL_BACK__), hl
	ei
	call __MEM_INIT
	call CLS
	xor a
	push af
	xor a
	push af
	call _printat40
	xor a
	call INK
	call COPY_ATTR
	ld a, 5
	call PAPER
	call COPY_ATTR
	ld a, 1
	call BRIGHT
	call COPY_ATTR
	ld a, 1
	call BORDER
	ld de, __LABEL1
	ld hl, __LABEL0
	call __ADDSTR
	push hl
	call _print40
	xor a
	call INK
	call COPY_ATTR
	ld a, 7
	call PAPER
	call COPY_ATTR
	xor a
	call BRIGHT
	call COPY_ATTR
	ld de, __LABEL1
	ld hl, __LABEL2
	call __ADDSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL3
	call __ADDSTR
	push hl
	call _print40
	ld de, __LABEL5
	ld hl, __LABEL4
	call __ADDSTR
	push hl
	ld de, __LABEL6
	pop hl
	push hl
	call __ADDSTR
	ex (sp), hl
	call __MEM_FREE
	pop hl
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
__LABEL__conectawifi:
	call _ConectarWiFi
	or a
	jp nz, __LABEL8
	call _ReintentarWiFi
	or a
	jp z, __LABEL9
	call CLS
	xor a
	push af
	xor a
	push af
	call _printat40
	jp __LABEL__conectawifi
__LABEL9:
	ld hl, __LABEL11
	call __LOADSTR
	push hl
	call _print40
	ld a, 8
	call __STOP
	ld hl, 0
	ld b, h
	ld c, l
__END_PROGRAM:
	di
	ld hl, (__CALL_BACK__)
	ld sp, hl
	exx
	pop hl
	exx
	pop iy
	pop ix
	ei
	ret
__CALL_BACK__:
	DEFW 0
__LABEL10:
__LABEL8:
	ld hl, 50
	call __PAUSE
	call CLS
	xor a
	push af
	xor a
	push af
	call _printat40
__LABEL__conectatcp:
	call _ConectarTCP
	or a
	jp nz, __LABEL13
	call _ReintentarTCP
	or a
	jp z, __LABEL14
	call CLS
	xor a
	push af
	xor a
	push af
	call _printat40
	jp __LABEL__conectatcp
__LABEL14:
	ld hl, __LABEL11
	call __LOADSTR
	push hl
	call _print40
	ld a, 8
	call __STOP
	ld hl, 0
	ld b, h
	ld c, l
	jp __END_PROGRAM
__LABEL15:
__LABEL13:
	ld hl, 50
	call __PAUSE
	call CLS
	xor a
	push af
	xor a
	push af
	call _printat40
__LABEL16:
	ld de, __LABEL18
	ld hl, _outBuffer
	call __STORE_STR
	ld hl, _outBuffer
	push hl
	ld a, 6
	push af
	call _ReadStream
	push af
	xor a
	pop hl
	call __LTI8
	or a
	jp z, __LABEL19
	ld hl, (_outBuffer)
	call __LOADSTR
	push hl
	call _print40
	jp __LABEL20
__LABEL19:
	ld hl, (_mLoop)
	inc hl
	ld (_mLoop), hl
	ld hl, 100
	ld de, (_mLoop)
	or a
	sbc hl, de
	jp nc, __LABEL22
	ld hl, 0
	ld (_mLoop), hl
	ld hl, _status
	push hl
	ld a, 5
	push af
	call _ReadByte
	or a
	jp z, __LABEL24
	ld a, (_status)
	sub 2
	jp z, __LABEL26
	ld a, (_status)
	call __U8TOFREG
	call __STR_FAST
	ex de, hl
	ld hl, __LABEL27
	push de
	call __ADDSTR
	ex (sp), hl
	call __MEM_FREE
	pop hl
	push hl
	ld de, __LABEL28
	pop hl
	push hl
	call __ADDSTR
	ex (sp), hl
	call __MEM_FREE
	pop hl
	push hl
	ld de, __LABEL1
	pop hl
	push hl
	call __ADDSTR
	ex (sp), hl
	call __MEM_FREE
	pop hl
	push hl
	call _print40
	call _ReintentarTCP
	or a
	jp z, __LABEL29
	call CLS
	xor a
	push af
	xor a
	push af
	call _printat40
	jp __LABEL__conectatcp
__LABEL29:
	ld hl, __LABEL11
	call __LOADSTR
	push hl
	call _print40
	ld a, 8
	call __STOP
	ld hl, 0
	ld b, h
	ld c, l
	jp __END_PROGRAM
__LABEL30:
__LABEL26:
__LABEL24:
__LABEL22:
__LABEL20:
	call INKEY
	ex de, hl
	ld hl, _outBuffer
	call __STORE_STR2
	ld de, __LABEL18
	ld hl, (_outBuffer)
	xor a
	call __STRNE
	push af
	ld de, (_lastKey)
	ld hl, (_outBuffer)
	xor a
	call __STRNE
	ld h, a
	pop af
	or a
	jr z, __LABEL178
	ld a, h
__LABEL178:
	or a
	jp z, __LABEL31
	ld de, __LABEL33
	ld hl, (_outBuffer)
	xor a
	call __STREQ
	or a
	jp z, __LABEL34
	ld hl, 64
	push hl
	call _input40
	ex de, hl
	ld hl, _outBuffer
	call __STORE_STR2
	jp __LABEL35
__LABEL34:
	ld de, (_outBuffer)
	ld hl, _lastKey
	call __STORE_STR
	ld de, __LABEL36
	ld hl, (_outBuffer)
	xor a
	call __STREQ
	or a
	jp z, __LABEL38
	ld de, __LABEL39
	ld hl, _outBuffer
	call __STORE_STR
__LABEL38:
	ld de, __LABEL2
	ld hl, (_outBuffer)
	xor a
	call __STREQ
	push af
	ld hl, 65025
	call _MultiKeys
	ld h, a
	pop af
	or a
	jr z, __LABEL179
	ld a, h
__LABEL179:
	or a
	jp z, __LABEL41
	ld hl, __LABEL11
	call __LOADSTR
	push hl
	call _print40
	ld a, 8
	call __STOP
	ld hl, 0
	ld b, h
	ld c, l
	jp __END_PROGRAM
__LABEL41:
__LABEL35:
	ld hl, _outBuffer
	push hl
	ld a, 7
	push af
	call _WriteStream
	jp __LABEL32
__LABEL31:
	ld de, __LABEL18
	ld hl, (_outBuffer)
	xor a
	call __STREQ
	or a
	jp z, __LABEL43
	ld de, __LABEL18
	ld hl, _lastKey
	call __STORE_STR
__LABEL43:
__LABEL32:
	jp __LABEL16
__LABEL17:
	ld hl, 0
	ld b, h
	ld c, l
	jp __END_PROGRAM
_EnableRegister:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	ld a, (ix+5)
	ld bc, 241
	out (c), a
	ld bc, 241
	in a, (c)
	ld (ix-1), a
	sub 255
	jp nz, __LABEL45
	ld a, 255
	jp _EnableRegister__leave
__LABEL45:
	ld a, (ix-1)
	push af
	ld h, 3
	pop af
	and h
	sub (ix+7)
	jp z, __LABEL47
	ld a, 254
	jp _EnableRegister__leave
__LABEL47:
	ld a, (ix+9)
	or a
	jp nz, __LABEL48
	ld a, (ix-1)
	push af
	ld h, 4
	pop af
	and h
	jp nz, __LABEL51
	ld a, 253
	jp _EnableRegister__leave
__LABEL51:
	jp __LABEL49
__LABEL48:
	ld a, (ix-1)
	push af
	ld h, 8
	pop af
	and h
	jp nz, __LABEL53
	ld a, 253
	jp _EnableRegister__leave
__LABEL53:
__LABEL49:
__LABEL54:
	ld bc, 243
	in a, (c)
	ld (ix-2), a
	sub 250
	jp nz, __LABEL58
	ld hl, 1
	call __PAUSE
__LABEL58:
__LABEL56:
	ld a, (ix-2)
	sub 250
	jp z, __LABEL54
__LABEL55:
	ld a, (ix-2)
_EnableRegister__leave:
	ld sp, ix
	pop ix
	exx
	pop hl
	pop bc
	pop bc
	ex (sp), hl
	exx
	ret
_ASMEnableRegister:
#line 52
		POP hl
		POP bc
		POP de
		PUSH hl
		OUT (241), A
		IN A, (241)
		PUSH AF
		XOR 255
		JR NZ, checktype
		POP AF
		LD A, 255
		RET
checktype:
		POP AF
		PUSH AF
		AND 3
		XOR B
		JR Z, checkop
		POP AF
		LD A, 0xFE
		RET
checkop:
		LD A, 1
		AND D
		JR NZ, writeop
readop:
		POP AF
		AND 4
		JR NZ, checklock
		LD A, 0xFD
		RET
writeop:
		POP AF
		AND 8
		JR NZ, checklock
		LD A, 0xFD
		RET
checklock:
		IN A, (243)
		XOR 250
		JR Z, checklock
		XOR 250
		RET
#line 95
_ASMEnableRegister__leave:
	ret
_ReadByte:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	inc sp
	xor a
	push af
	xor a
	push af
	ld a, (ix+5)
	call _ASMEnableRegister
	ld (ix-1), a
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL60
	ld a, 255
	jp _ReadByte__leave
__LABEL60:
	ld bc, 245
	in a, (c)
	ld h, (ix+7)
	ld l, (ix+6)
	ld (hl), a
	ld a, 1
_ReadByte__leave:
	ld sp, ix
	pop ix
	exx
	pop hl
	pop bc
	ex (sp), hl
	exx
	ret
_ReadInteger:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	push hl
	push hl
	inc sp
	xor a
	push af
	ld a, 1
	push af
	ld a, (ix+5)
	call _ASMEnableRegister
	ld (ix-1), a
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL62
	ld a, 255
	jp _ReadInteger__leave
__LABEL62:
	ld bc, 245
	in a, (c)
	ld l, a
	ld h, 0
	ld e, h
	ld d, h
	ld bc, -5
	call __PSTORE32
	ld l, (ix-5)
	ld h, (ix-4)
	ld e, (ix-3)
	ld d, (ix-2)
	ld b, 24
__LABEL180:
	call __SHL32
	djnz __LABEL180
	ld bc, 6
	call __PISTORE32
	ld bc, 245
	in a, (c)
	ld l, a
	ld h, 0
	ld e, h
	ld d, h
	ld bc, -5
	call __PSTORE32
	ld h, (ix+7)
	ld l, (ix+6)
	call __ILOAD32
	push de
	push hl
	ld l, (ix-5)
	ld h, (ix-4)
	ld e, (ix-3)
	ld d, (ix-2)
	ld b, 16
__LABEL181:
	call __SHL32
	djnz __LABEL181
	call __BOR32
	ld bc, 6
	call __PISTORE32
	ld bc, 245
	in a, (c)
	ld l, a
	ld h, 0
	ld e, h
	ld d, h
	ld bc, -5
	call __PSTORE32
	ld h, (ix+7)
	ld l, (ix+6)
	call __ILOAD32
	push de
	push hl
	ld l, (ix-5)
	ld h, (ix-4)
	ld e, (ix-3)
	ld d, (ix-2)
	ld b, 8
__LABEL182:
	call __SHL32
	djnz __LABEL182
	call __BOR32
	ld bc, 6
	call __PISTORE32
	ld bc, 245
	in a, (c)
	ld l, a
	ld h, 0
	ld e, h
	ld d, h
	ld bc, -5
	call __PSTORE32
	ld h, (ix+7)
	ld l, (ix+6)
	call __ILOAD32
	push de
	push hl
	ld l, (ix-5)
	ld h, (ix-4)
	ld e, (ix-3)
	ld d, (ix-2)
	call __BOR32
	ld bc, 6
	call __PISTORE32
	ld a, 1
_ReadInteger__leave:
	ld sp, ix
	pop ix
	exx
	pop hl
	pop bc
	ex (sp), hl
	exx
	ret
_ReadStream:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	push hl
	inc sp
	xor a
	push af
	ld a, 2
	push af
	ld a, (ix+5)
	call _ASMEnableRegister
	ld (ix-1), a
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL64
	ld a, 255
	jp _ReadStream__leave
__LABEL64:
	ld (ix-3), 1
	ld (ix-2), 0
	jp __LABEL65
__LABEL68:
	ld h, (ix+7)
	ld l, (ix+6)
	ld c, (hl)
	inc hl
	ld h, (hl)
	ld l, c
	push hl
	ld bc, 245
	in a, (c)
	push af
	ld hl, 1
	call CHR
	ex de, hl
	pop hl
	push de
	call __ADDSTR
	ex (sp), hl
	call __MEM_FREE
	pop hl
	ld d, h
	ld e, l
	ld bc, 6
	call __PISTORE_STR2
__LABEL69:
	ld l, (ix-3)
	ld h, (ix-2)
	inc hl
	ld (ix-3), l
	ld (ix-2), h
__LABEL65:
	ld l, (ix-3)
	ld h, (ix-2)
	push hl
	ld a, (ix-1)
	ld l, a
	add a, a
	sbc a, a
	ld h, a
	pop de
	or a
	sbc hl, de
	jp nc, __LABEL68
__LABEL67:
	ld a, (ix-1)
_ReadStream__leave:
	ld sp, ix
	pop ix
	exx
	pop hl
	pop bc
	ex (sp), hl
	exx
	ret
_WriteByte:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	inc sp
	ld a, 1
	push af
	xor a
	push af
	ld a, (ix+5)
	call _ASMEnableRegister
	ld (ix-1), a
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL71
	ld a, 255
	jp _WriteByte__leave
__LABEL71:
	ld a, (ix+7)
	ld bc, 245
	out (c), a
	ld a, 1
_WriteByte__leave:
	ld sp, ix
	pop ix
	exx
	pop hl
	pop bc
	ex (sp), hl
	exx
	ret
_WriteInteger:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	inc sp
	ld a, 1
	push af
	ld a, 1
	push af
	ld a, (ix+5)
	call _ASMEnableRegister
	ld (ix-1), a
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL73
	ld a, 255
	jp _WriteInteger__leave
__LABEL73:
	ld l, (ix+6)
	ld h, (ix+7)
	ld e, (ix+8)
	ld d, (ix+9)
	ld b, 24
__LABEL183:
	call __SHRL32
	djnz __LABEL183
	push de
	push hl
	ld de, 0
	ld hl, 255
	call __BAND32
	ld a, l
	ld bc, 245
	out (c), a
	ld l, (ix+6)
	ld h, (ix+7)
	ld e, (ix+8)
	ld d, (ix+9)
	ld b, 16
__LABEL184:
	call __SHRL32
	djnz __LABEL184
	push de
	push hl
	ld de, 0
	ld hl, 255
	call __BAND32
	ld a, l
	ld bc, 245
	out (c), a
	ld l, (ix+6)
	ld h, (ix+7)
	ld e, (ix+8)
	ld d, (ix+9)
	ld b, 8
__LABEL185:
	call __SHRL32
	djnz __LABEL185
	push de
	push hl
	ld de, 0
	ld hl, 255
	call __BAND32
	ld a, l
	ld bc, 245
	out (c), a
	ld l, (ix+6)
	ld h, (ix+7)
	ld e, (ix+8)
	ld d, (ix+9)
	push de
	push hl
	ld de, 0
	ld hl, 255
	call __BAND32
	ld a, l
	ld bc, 245
	out (c), a
	ld a, 1
_WriteInteger__leave:
	ld sp, ix
	pop ix
	exx
	pop hl
	pop bc
	pop bc
	ex (sp), hl
	exx
	ret
_WriteStream:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	push hl
	ld a, 1
	push af
	ld a, 2
	push af
	ld a, (ix+5)
	call _ASMEnableRegister
	ld (ix-1), a
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL75
	ld a, 255
	jp _WriteStream__leave
__LABEL75:
	ld h, (ix+7)
	ld l, (ix+6)
	ld c, (hl)
	inc hl
	ld h, (hl)
	ld l, c
	call __STRLEN
	ld a, l
	ld (ix-2), a
	push af
	ld a, 64
	pop hl
	cp h
	jp nc, __LABEL77
	ld a, 254
	jp _WriteStream__leave
__LABEL77:
	ld a, (ix-1)
	sub (ix-2)
	jp z, __LABEL79
	ld a, (ix-2)
	ld bc, 243
	out (c), a
__LABEL79:
	ld (ix-4), 0
	ld (ix-3), 0
	jp __LABEL80
__LABEL83:
	ld h, (ix+7)
	ld l, (ix+6)
	ld c, (hl)
	inc hl
	ld h, (hl)
	ld l, c
	push hl
	ld l, (ix-4)
	ld h, (ix-3)
	push hl
	ld l, (ix-4)
	ld h, (ix-3)
	push hl
	xor a
	call __STRSLICE
	ld a, 1
	call __ASC
	ld bc, 245
	out (c), a
__LABEL84:
	ld l, (ix-4)
	ld h, (ix-3)
	inc hl
	ld (ix-4), l
	ld (ix-3), h
__LABEL80:
	ld l, (ix-4)
	ld h, (ix-3)
	push hl
	ld a, (ix-2)
	dec a
	ld l, a
	ld h, 0
	pop de
	or a
	sbc hl, de
	jp nc, __LABEL83
__LABEL82:
	ld a, 1
_WriteStream__leave:
	ld sp, ix
	pop ix
	exx
	pop hl
	pop bc
	ex (sp), hl
	exx
	ret
_print40:
	push ix
	ld ix, 0
	add ix, sp
#line 21
		PROC
		LD A, H
		OR L
		JP Z, print40end
		LD C,(HL)
		INC HL
		LD B,(HL)
		LD A, C
		OR B
		JP Z, print40end
		INC HL
		LOCAL examineChar
examineChar:
		LD A,(HL)
		CP 128
		JR NC, nextChar
		CP 22
		JR NZ, isNewline
		LOCAL isAt
isAt:
		EX DE,HL
		LD HL, -2
		ADD HL, BC
		EX DE,HL
		JP NC, print40end
		INC HL
		LD D,(HL)
		DEC BC
		INC HL
		LD E,(HL)
		DEC BC
		ld (xycoords), de
		JR nextChar
		LOCAL isNewline
isNewline:
		CP 13
		JR NZ, checkdel
		LOCAL newline
newline:
		ld de, (xycoords)
		CALL nxtline
		ld (xycoords), de
		JR nextChar
		LOCAL checkdel
checkdel:
		CP 8
		JR NZ, checkvalid
		ld de, (xycoords)
		dec de
		ld (xycoords), de
		ld a, 41
		cp e
		JR NC, nextChar
		ld e, a
		ld (xycoords), de
		ld a, 23
		cp d
		JR NC, nextChar
		ld d, a
		ld (xycoords), de
		JR nextChar
		LOCAL checkvalid
checkvalid:
		CP 31
		JR C, nextChar
		LOCAL prn
prn:
		PUSH HL
		PUSH BC
		CALL printachar
		POP BC
		POP HL
		LOCAL nextChar
nextChar:
		INC HL
		DEC BC
		LD A,B
		OR C
		JR NZ, examineChar
		JP print40end
		LOCAL printachar
printachar:
		EXX
		PUSH HL
		EXX
		ld c, a
		ld h, 0
		ld l, a
		ld de, whichcolumn-32
		add hl, de
		ld a, (hl)
		cp 32
		jr nc, calcChar
		ld de, characters
		ld l, a
		call mult8
		ld b, h
		ld c, l
		jr printdata
		LOCAL calcChar
calcChar:
		ld de, 15360
		ld l, c
		call mult8
		ld de, workspace
		push de
		exx
		ld c, a
		cpl
		ld b, a
		exx
		ld b, 8
		LOCAL loop1
loop1:
		ld a, (hl)
		inc hl
		exx
		ld e, a
		and c
		ld d, a
		ld a, e
		rla
		and b
		or d
		exx
		ld (de), a
		inc de
		djnz loop1
		pop bc
		LOCAL printdata
printdata:
		call testcoords
		inc e
		ld (xycoords), de
		dec e
		ld a, e
		sla a
		ld l, a
		sla a
		add a, l
		ld l, a
		srl a
		srl a
		srl a
		ld e, a
		ld a, l
		and 7
		push af
		ex af, af'
		ld a, d
		sra a
		sra a
		sra a
		add a, 88
		ld h, a
		ld a, d
		and 7
		rrca
		rrca
		rrca
		add a, e
		ld l, a
		ld a, (23693)
		ld e, a
		ld (hl), e
		inc hl
		pop af
		cp 3
		jr c, hop1
		ld (hl), e
		LOCAL hop1
hop1:
		dec hl
		ld a, d
		and 248
		add a, 64
		ld h, a
		push hl
		exx
		pop hl
		exx
		ld a, 8
		LOCAL hop4
hop4:
		push af
		ld a, (bc)
		exx
		push hl
		ld c, 0
		ld de, 1023
		ex af, af'
		and a
		jr z, hop3
		ld b, a
		ex af, af'
		LOCAL hop2
hop2:
		and a
		rra
		rr c
		scf
		rr d
		rr e
		djnz hop2
		ex af, af'
		LOCAL hop3
hop3:
		ex af, af'
		ld b, a
		ld a, (hl)
		and d
		or b
		ld (hl), a
		inc hl
		ld a, (hl)
		and e
		or c
		ld (hl), a
		pop hl
		inc h
		exx
		inc bc
		pop af
		dec a
		jr nz, hop4
		exx
		pop hl
		exx
		ret
		LOCAL mult8
mult8:
		ld h, 0
		add hl, hl
		add hl, hl
		add hl, hl
		add hl, de
		ret
		LOCAL testcoords
testcoords:
		ld de, (xycoords)
		LOCAL nxtchar
nxtchar:
		ld a, e
		cp 40
		jr c, ycoord
		LOCAL nxtline
nxtline:
		inc d
		ld e, 0
		LOCAL ycoord
ycoord:
		ld a, d
		cp 24
		ret c
		dec d
		call scroll
		ret
		LOCAL scroll
scroll:
		push af
		push bc
		push de
		push hl
		ld de, 16384
		ld hl, 16384 + 32
		LOCAL scrltop
scrltop:
		ld bc, 7 * 32
		ldir
		ld b, 7
		add hl, bc
		ld bc, 32
		ldir
		ld b, -7
		add hl, bc
		bit 4, h
		jr z, scrltop
		ld a, 8
		LOCAL scrlbot
scrlbot:
		ld d, h
		ld e, 0
		push hl
		ld bc, 7 * 32
		ldir
		ld b, 32
		ex de, hl
		LOCAL scrlblnk
scrlblnk:
		ld(hl),c
		inc hl
		djnz scrlblnk
		pop hl
		inc h
		dec a
		jr nz, scrlbot
		pop hl
		pop de
		pop bc
		pop af
		ret
#line 322
__LABEL__printAt40Coords:
#line 406
		LOCAL xycoords
xycoords:
		defb 0
		defb 0
		LOCAL workspace
workspace:
		defb 0
		defb 0
		defb 0
		defb 0
		defb 0
		defb 0
		defb 0
		defb 0
		LOCAL whichcolumn
whichcolumn:
		defb 254
		defb 254
		defb 128
		defb 224
		defb 128
		defb 0
		defb 1
		defb 128
		defb 128
		defb 128
		defb 128
		defb 128
		defb 128
		defb 128
		defb 128
		defb 128
		defb 2
		defb 128
		defb 224
		defb 224
		defb 252
		defb 224
		defb 224
		defb 192
		defb 240
		defb 240
		defb 240
		defb 240
		defb 192
		defb 240
		defb 192
		defb 192
		defb 248
		defb 240
		defb 240
		defb 240
		defb 240
		defb 240
		defb 240
		defb 240
		defb 240
		defb 128
		defb 240
		defb 192
		defb 240
		defb 240
		defb 248
		defb 240
		defb 240
		defb 248
		defb 240
		defb 240
		defb 3
		defb 240
		defb 240
		defb 240
		defb 240
		defb 4
		defb 252
		defb 224
		defb 252
		defb 240
		defb 252
		defb 6
		defb 240
		defb 255
		defb 128
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 255
		defb 128
		defb 128
		defb 255
		defb 128
		defb 5
		LOCAL characters
characters:
		defb 0
		defb 0
		defb 100
		defb 104
		defb 16
		defb 44
		defb 76
		defb 0
		defb 0
		defb 32
		defb 80
		defb 32
		defb 84
		defb 72
		defb 52
		defb 0
		defb 0
		defb 56
		defb 76
		defb 84
		defb 84
		defb 100
		defb 56
		defb 0
		defb 0
		defb 124
		defb 16
		defb 16
		defb 16
		defb 16
		defb 16
		defb 0
		defb 0
		defb 68
		defb 68
		defb 40
		defb 16
		defb 16
		defb 16
		defb 0
		defb 0
		defb 48
		defb 72
		defb 180
		defb 164
		defb 180
		defb 72
		defb 48
		defb 0
		defb 0
		defb 0
		defb 0
		defb 0
		defb 0
		defb 0
		defb 0xFC
		LOCAL print40end
print40end:
		ENDP
#line 579
_print40__leave:
	ex af, af'
	exx
	ld l, (ix+4)
	ld h, (ix+5)
	call __MEM_FREE
	ex af, af'
	exx
	ld sp, ix
	pop ix
	exx
	pop hl
	ex (sp), hl
	exx
	ret
_printat40:
	push ix
	ld ix, 0
	add ix, sp
	ld a, (ix+7)
	ld (__LABEL__printAt40Coords), a
	ld a, (ix+5)
	ld ((__LABEL__printAt40Coords) + (1)), a
_printat40__leave:
	ld sp, ix
	pop ix
	exx
	pop hl
	pop bc
	ex (sp), hl
	exx
	ret
_pos:
#line 27
		PROC
		call __LOAD_S_POSN
		ld a, e
		ENDP
#line 31
_pos__leave:
	ret
_csrlin:
#line 25
		PROC
		call __LOAD_S_POSN
		ld a, d
		ENDP
#line 29
_csrlin__leave:
	ret
_input40:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	push hl
	ld de, __LABEL18
	ld bc, -2
	call __PSTORE_STR
	ld a, (23611)
	push af
	ld h, 8
	pop af
	or h
	ld (23611), a
__LABEL85:
	call _PRIVATEInputShowCursor42
	xor a
	ld (_input40_LastK), a
__LABEL88:
__LABEL90:
	ld a, (_input40_LastK)
	or a
	jp z, __LABEL88
__LABEL89:
	call _PRIVATEInputHideCursor42
	ld a, (_input40_LastK)
	sub 12
	jp nz, __LABEL91
	ld l, (ix-2)
	ld h, (ix-1)
	call __STRLEN
	ld a, h
	or l
	jp z, __LABEL94
	ld l, (ix-2)
	ld h, (ix-1)
	call __STRLEN
	push hl
	ld de, 1
	pop hl
	or a
	sbc hl, de
	jp nz, __LABEL95
	ld de, __LABEL18
	ld bc, -2
	call __PSTORE_STR
	jp __LABEL96
__LABEL95:
	ld l, (ix-2)
	ld h, (ix-1)
	push hl
	ld hl, 0
	push hl
	ld l, (ix-2)
	ld h, (ix-1)
	call __STRLEN
	dec hl
	dec hl
	push hl
	xor a
	call __STRSLICE
	ld d, h
	ld e, l
	ld bc, -2
	call __PSTORE_STR2
__LABEL96:
	ld hl, __LABEL39
	call __LOADSTR
	push hl
	call _print40
__LABEL94:
	jp __LABEL92
__LABEL91:
	ld a, (_input40_LastK)
	sub 32
	ccf
	sbc a, a
	push af
	ld l, (ix-2)
	ld h, (ix-1)
	call __STRLEN
	push hl
	ld l, (ix+4)
	ld h, (ix+5)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	sbc a, a
	ld h, a
	pop af
	or a
	jr z, __LABEL186
	ld a, h
__LABEL186:
	or a
	jp z, __LABEL98
	ld l, (ix-2)
	ld h, (ix-1)
	push hl
	ld a, (_input40_LastK)
	push af
	ld hl, 1
	call CHR
	ex de, hl
	pop hl
	push de
	call __ADDSTR
	ex (sp), hl
	call __MEM_FREE
	pop hl
	ld d, h
	ld e, l
	ld bc, -2
	call __PSTORE_STR2
	ld a, (_input40_LastK)
	push af
	ld hl, 1
	call CHR
	push hl
	call _print40
__LABEL98:
__LABEL92:
__LABEL87:
	ld a, (_input40_LastK)
	sub 13
	jp nz, __LABEL85
__LABEL86:
	ld (ix-4), 1
	ld (ix-3), 0
	jp __LABEL99
__LABEL102:
	ld a, 8
	push af
	ld hl, 1
	call CHR
	push hl
	ld de, __LABEL2
	pop hl
	push hl
	call __ADDSTR
	ex (sp), hl
	call __MEM_FREE
	pop hl
	push hl
	ld a, 8
	push af
	ld hl, 1
	call CHR
	ex de, hl
	pop hl
	push hl
	push de
	call __ADDSTR
	pop de
	ex (sp), hl
	push de
	call __MEM_FREE
	pop hl
	call __MEM_FREE
	pop hl
	push hl
	call _print40
__LABEL103:
	ld l, (ix-4)
	ld h, (ix-3)
	inc hl
	ld (ix-4), l
	ld (ix-3), h
__LABEL99:
	ld l, (ix-4)
	ld h, (ix-3)
	push hl
	ld l, (ix-2)
	ld h, (ix-1)
	call __STRLEN
	pop de
	or a
	sbc hl, de
	jp nc, __LABEL102
__LABEL101:
	ld l, (ix-2)
	ld h, (ix-1)
	call __LOADSTR
_input40__leave:
	ex af, af'
	exx
	ld l, (ix-2)
	ld h, (ix-1)
	call __MEM_FREE
	ex af, af'
	exx
	ld sp, ix
	pop ix
	exx
	pop hl
	ex (sp), hl
	exx
	ret
_PRIVATEInputShowCursor42:
	ld a, 1
	call OVER
	call COPY_ATTR
	ld de, __LABEL39
	ld hl, __LABEL104
	call __ADDSTR
	push hl
	call _print40
	xor a
	call OVER
_PRIVATEInputShowCursor42__leave:
	ret
	call COPY_ATTR
_PRIVATEInputHideCursor42:
	xor a
	call OVER
	call COPY_ATTR
	ld de, __LABEL39
	ld hl, __LABEL2
	call __ADDSTR
	push hl
	call _print40
_PRIVATEInputHideCursor42__leave:
	ret
_GetKey:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	inc sp
__LABEL105:
	call INKEY
	ld a, 1
	call __ASC
	ld (ix-1), a
__LABEL107:
	ld a, (ix-1)
	or a
	jp z, __LABEL105
__LABEL106:
	ld a, (ix-1)
_GetKey__leave:
	ld sp, ix
	pop ix
	ret
_MultiKeys:
#line 41
		ld a, h
		in a, (0FEh)
		cpl
		and l
#line 45
_MultiKeys__leave:
	ret
_GetKeyScanCode:
#line 59
		PROC
		LOCAL END_KEY
		LOCAL LOOP
		ld l, 1
		ld a, l
LOOP:
		cpl
		ld h, a
		in a, (0FEh)
		cpl
		and 1Fh
		jr nz, END_KEY
		ld a, l
		rla
		ld l, a
		jr nc, LOOP
		ld h, a
END_KEY:
		ld l, a
		ENDP
#line 79
_GetKeyScanCode__leave:
	ret
_ConectarWiFi:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	push hl
	push hl
	inc sp
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL108
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
__LABEL__enterssid:
	ld de, __LABEL1
	ld hl, __LABEL109
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	ld hl, 64
	push hl
	call _input40
	ld d, h
	ld e, l
	ld bc, -3
	call __PSTORE_STR2
	ld l, (ix-3)
	ld h, (ix-2)
	call __STRLEN
	push hl
	ld de, 0
	pop hl
	or a
	sbc hl, de
	jp nz, __LABEL111
	ld de, __LABEL1
	ld hl, __LABEL112
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	jp __LABEL__enterssid
__LABEL111:
__LABEL__enterpass:
	ld de, __LABEL1
	ld hl, __LABEL113
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	ld hl, 64
	push hl
	call _input40
	ld d, h
	ld e, l
	ld bc, -5
	call __PSTORE_STR2
	ld l, (ix-5)
	ld h, (ix-4)
	call __STRLEN
	push hl
	ld de, 0
	pop hl
	or a
	sbc hl, de
	jp nz, __LABEL115
	ld de, __LABEL1
	ld hl, __LABEL116
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	jp __LABEL__enterpass
__LABEL115:
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL117
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	push ix
	pop hl
	ld de, -3
	add hl, de
	push hl
	xor a
	push af
	call _WriteStream
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL119
	ld de, __LABEL1
	ld hl, __LABEL120
	call __ADDSTR
	push hl
	call _print40
	xor a
	jp _ConectarWiFi__leave
__LABEL119:
	push ix
	pop hl
	ld de, -5
	add hl, de
	push hl
	ld a, 1
	push af
	call _WriteStream
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL122
	ld de, __LABEL1
	ld hl, __LABEL123
	call __ADDSTR
	push hl
	call _print40
	xor a
	jp _ConectarWiFi__leave
__LABEL122:
	ld a, 1
	push af
	ld a, 2
	push af
	call _WriteByte
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL125
	ld de, __LABEL1
	ld hl, __LABEL126
	call __ADDSTR
	push hl
	call _print40
	xor a
	jp _ConectarWiFi__leave
__LABEL125:
__LABEL127:
	push ix
	pop hl
	ld de, -1
	add hl, de
	push hl
	ld a, 2
	push af
	call _ReadByte
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL130
	ld (ix-1), 255
	jp __LABEL128
__LABEL130:
	ld a, (ix-1)
	push af
	ld a, 1
	pop hl
	cp h
	jp c, __LABEL128
__LABEL132:
	jp __LABEL127
__LABEL128:
	ld a, (ix-1)
	sub 2
	jp nz, __LABEL133
	ld de, __LABEL1
	ld hl, __LABEL135
	call __ADDSTR
	push hl
	call _print40
	ld a, 1
	jp _ConectarWiFi__leave
__LABEL133:
	ld de, __LABEL1
	ld hl, __LABEL136
	call __ADDSTR
	push hl
	call _print40
	xor a
	jp _ConectarWiFi__leave
__LABEL134:
_ConectarWiFi__leave:
	ex af, af'
	exx
	ld l, (ix-3)
	ld h, (ix-2)
	call __MEM_FREE
	ld l, (ix-5)
	ld h, (ix-4)
	call __MEM_FREE
	ex af, af'
	exx
	ld sp, ix
	pop ix
	ret
_ReintentarWiFi:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
__LABEL__retrywifi:
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL137
	call __ADDSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL138
	call __ADDSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL139
	call __ADDSTR
	push hl
	call _print40
	ld hl, 1
	push hl
	call _input40
	ld d, h
	ld e, l
	ld bc, -2
	call __PSTORE_STR2
	ld l, (ix-2)
	ld h, (ix-1)
	push hl
	ld de, __LABEL140
	pop hl
	xor a
	call __STREQ
	or a
	jp z, __LABEL142
	ld a, 1
	jp _ReintentarWiFi__leave
__LABEL142:
	ld l, (ix-2)
	ld h, (ix-1)
	push hl
	ld de, __LABEL143
	pop hl
	xor a
	call __STREQ
	or a
	jp z, __LABEL145
	xor a
	jp _ReintentarWiFi__leave
__LABEL145:
	call CLS
	xor a
	push af
	xor a
	push af
	call _printat40
	ld de, __LABEL1
	ld hl, __LABEL146
	call __ADDSTR
	push hl
	call _print40
	jp __LABEL__retrywifi
_ReintentarWiFi__leave:
	ex af, af'
	exx
	ld l, (ix-2)
	ld h, (ix-1)
	call __MEM_FREE
	ex af, af'
	exx
	ld sp, ix
	pop ix
	ret
_ConectarTCP:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, -7
	add hl, sp
	ld sp, hl
	ld (hl), 0
	ld bc, 6
	ld d, h
	ld e, l
	inc de
	ldir
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL147
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
__LABEL__enteraddress:
	ld de, __LABEL1
	ld hl, __LABEL148
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	ld hl, 64
	push hl
	call _input40
	ld d, h
	ld e, l
	ld bc, -3
	call __PSTORE_STR2
	ld l, (ix-3)
	ld h, (ix-2)
	call __STRLEN
	push hl
	ld de, 0
	pop hl
	or a
	sbc hl, de
	jp nz, __LABEL150
	ld de, __LABEL1
	ld hl, __LABEL151
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	jp __LABEL__enteraddress
__LABEL150:
__LABEL__enterport:
	ld de, __LABEL1
	ld hl, __LABEL152
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	ld hl, 64
	push hl
	call _input40
	ld d, h
	ld e, l
	ld bc, -5
	call __PSTORE_STR2
	ld l, (ix-5)
	ld h, (ix-4)
	call __STRLEN
	push hl
	ld de, 0
	pop hl
	or a
	sbc hl, de
	jp nz, __LABEL154
	ld de, __LABEL1
	ld hl, __LABEL155
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	jp __LABEL__enterport
__LABEL154:
	ld l, (ix-5)
	ld h, (ix-4)
	xor a
	call VAL
	call __FTOU32REG
	ld (ix-7), l
	ld (ix-6), h
	ld l, (ix-7)
	ld h, (ix-6)
	push hl
	ld de, 0
	pop hl
	or a
	sbc hl, de
	jp nz, __LABEL157
	ld de, __LABEL1
	ld hl, __LABEL155
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	jp __LABEL__enterport
__LABEL157:
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL117
	call __ADDSTR
	push hl
	call _print40
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	push ix
	pop hl
	ld de, -3
	add hl, de
	push hl
	ld a, 3
	push af
	call _WriteStream
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL159
	ld de, __LABEL1
	ld hl, __LABEL160
	call __ADDSTR
	push hl
	call _print40
	xor a
	jp _ConectarTCP__leave
__LABEL159:
	ld l, (ix-7)
	ld h, (ix-6)
	ld de, 0
	push de
	push hl
	ld a, 4
	push af
	call _WriteInteger
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL162
	ld de, __LABEL1
	ld hl, __LABEL163
	call __ADDSTR
	push hl
	call _print40
	xor a
	jp _ConectarTCP__leave
__LABEL162:
	ld a, 1
	push af
	ld a, 5
	push af
	call _WriteByte
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL165
	ld de, __LABEL1
	ld hl, __LABEL126
	call __ADDSTR
	push hl
	call _print40
	xor a
	jp _ConectarTCP__leave
__LABEL165:
__LABEL166:
	push ix
	pop hl
	ld de, -1
	add hl, de
	push hl
	ld a, 5
	push af
	call _ReadByte
	push af
	ld h, 0
	pop af
	call __LTI8
	or a
	jp z, __LABEL169
	ld (ix-1), 255
	jp __LABEL167
__LABEL169:
	ld a, (ix-1)
	push af
	ld a, 1
	pop hl
	cp h
	jp c, __LABEL167
__LABEL171:
	jp __LABEL166
__LABEL167:
	push ix
	pop hl
	ld de, -1
	add hl, de
	push hl
	ld a, 5
	push af
	call _ReadByte
	ld a, (ix-1)
	sub 2
	jp nz, __LABEL172
	ld de, __LABEL1
	ld hl, __LABEL135
	call __ADDSTR
	push hl
	call _print40
	ld a, 1
	jp _ConectarTCP__leave
__LABEL172:
	ld de, __LABEL1
	ld hl, __LABEL136
	call __ADDSTR
	push hl
	call _print40
	xor a
	jp _ConectarTCP__leave
__LABEL173:
_ConectarTCP__leave:
	ex af, af'
	exx
	ld l, (ix-3)
	ld h, (ix-2)
	call __MEM_FREE
	ld l, (ix-5)
	ld h, (ix-4)
	call __MEM_FREE
	ex af, af'
	exx
	ld sp, ix
	pop ix
	ret
_ReintentarTCP:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
__LABEL__retrytcp:
	ld hl, __LABEL1
	call __LOADSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL137
	call __ADDSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL138
	call __ADDSTR
	push hl
	call _print40
	ld de, __LABEL1
	ld hl, __LABEL139
	call __ADDSTR
	push hl
	call _print40
	ld hl, 1
	push hl
	call _input40
	ld d, h
	ld e, l
	ld bc, -2
	call __PSTORE_STR2
	ld l, (ix-2)
	ld h, (ix-1)
	push hl
	ld de, __LABEL140
	pop hl
	xor a
	call __STREQ
	or a
	jp z, __LABEL175
	ld a, 1
	jp _ReintentarTCP__leave
__LABEL175:
	ld l, (ix-2)
	ld h, (ix-1)
	push hl
	ld de, __LABEL143
	pop hl
	xor a
	call __STREQ
	or a
	jp z, __LABEL177
	xor a
	jp _ReintentarTCP__leave
__LABEL177:
	call CLS
	xor a
	push af
	xor a
	push af
	call _printat40
	ld de, __LABEL1
	ld hl, __LABEL146
	call __ADDSTR
	push hl
	call _print40
	jp __LABEL__retrytcp
_ReintentarTCP__leave:
	ex af, af'
	exx
	ld l, (ix-2)
	ld h, (ix-1)
	call __MEM_FREE
	ex af, af'
	exx
	ld sp, ix
	pop ix
	ret
__LABEL0:
	DEFW 0028h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 5Ah
	DEFB 58h
	DEFB 20h
	DEFB 54h
	DEFB 45h
	DEFB 4Ch
	DEFB 4Eh
	DEFB 45h
	DEFB 54h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
__LABEL1:
	DEFW 0001h
	DEFB 0Dh
__LABEL2:
	DEFW 0001h
	DEFB 20h
__LABEL3:
	DEFW 0024h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 42h
	DEFB 69h
	DEFB 65h
	DEFB 6Eh
	DEFB 76h
	DEFB 65h
	DEFB 6Eh
	DEFB 69h
	DEFB 64h
	DEFB 6Fh
	DEFB 20h
	DEFB 61h
	DEFB 6Ch
	DEFB 20h
	DEFB 63h
	DEFB 6Ch
	DEFB 69h
	DEFB 65h
	DEFB 6Eh
	DEFB 74h
	DEFB 65h
	DEFB 20h
	DEFB 64h
	DEFB 65h
	DEFB 20h
	DEFB 54h
	DEFB 65h
	DEFB 6Ch
	DEFB 6Eh
	DEFB 65h
	DEFB 74h
__LABEL4:
	DEFW 000Bh
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
__LABEL5:
	DEFW 0001h
	DEFB 7Fh
__LABEL6:
	DEFW 0012h
	DEFB 32h
	DEFB 30h
	DEFB 32h
	DEFB 30h
	DEFB 20h
	DEFB 45h
	DEFB 6Ch
	DEFB 20h
	DEFB 44h
	DEFB 72h
	DEFB 2Eh
	DEFB 20h
	DEFB 47h
	DEFB 75h
	DEFB 73h
	DEFB 6Dh
	DEFB 61h
	DEFB 6Eh
__LABEL11:
	DEFW 0004h
	DEFB 42h
	DEFB 79h
	DEFB 65h
	DEFB 21h
__LABEL18:
	DEFW 0000h
__LABEL27:
	DEFW 0014h
	DEFB 43h
	DEFB 6Fh
	DEFB 6Eh
	DEFB 65h
	DEFB 78h
	DEFB 69h
	DEFB 6Fh
	DEFB 6Eh
	DEFB 20h
	DEFB 74h
	DEFB 65h
	DEFB 72h
	DEFB 6Dh
	DEFB 69h
	DEFB 6Eh
	DEFB 61h
	DEFB 64h
	DEFB 61h
	DEFB 20h
	DEFB 28h
__LABEL28:
	DEFW 0001h
	DEFB 29h
__LABEL33:
	DEFW 0001h
	DEFB 07h
__LABEL36:
	DEFW 0001h
	DEFB 0Ch
__LABEL39:
	DEFW 0001h
	DEFB 08h
__LABEL104:
	DEFW 0001h
	DEFB 5Fh
__LABEL108:
	DEFW 0011h
	DEFB 2Dh
	DEFB 43h
	DEFB 6Fh
	DEFB 6Eh
	DEFB 65h
	DEFB 63h
	DEFB 74h
	DEFB 61h
	DEFB 72h
	DEFB 20h
	DEFB 61h
	DEFB 6Ch
	DEFB 20h
	DEFB 57h
	DEFB 69h
	DEFB 46h
	DEFB 69h
__LABEL109:
	DEFW 001Bh
	DEFB 20h
	DEFB 20h
	DEFB 49h
	DEFB 6Eh
	DEFB 64h
	DEFB 69h
	DEFB 63h
	DEFB 61h
	DEFB 20h
	DEFB 65h
	DEFB 6Ch
	DEFB 20h
	DEFB 53h
	DEFB 53h
	DEFB 49h
	DEFB 44h
	DEFB 20h
	DEFB 64h
	DEFB 65h
	DEFB 6Ch
	DEFB 20h
	DEFB 72h
	DEFB 6Fh
	DEFB 75h
	DEFB 74h
	DEFB 65h
	DEFB 72h
__LABEL112:
	DEFW 000Fh
	DEFB 53h
	DEFB 53h
	DEFB 49h
	DEFB 44h
	DEFB 20h
	DEFB 69h
	DEFB 6Eh
	DEFB 63h
	DEFB 6Fh
	DEFB 72h
	DEFB 72h
	DEFB 65h
	DEFB 63h
	DEFB 74h
	DEFB 6Fh
__LABEL113:
	DEFW 0014h
	DEFB 20h
	DEFB 20h
	DEFB 49h
	DEFB 6Eh
	DEFB 64h
	DEFB 69h
	DEFB 63h
	DEFB 61h
	DEFB 20h
	DEFB 65h
	DEFB 6Ch
	DEFB 20h
	DEFB 70h
	DEFB 61h
	DEFB 73h
	DEFB 73h
	DEFB 77h
	DEFB 6Fh
	DEFB 72h
	DEFB 64h
__LABEL116:
	DEFW 0013h
	DEFB 50h
	DEFB 61h
	DEFB 73h
	DEFB 73h
	DEFB 77h
	DEFB 6Fh
	DEFB 72h
	DEFB 64h
	DEFB 20h
	DEFB 69h
	DEFB 6Eh
	DEFB 63h
	DEFB 6Fh
	DEFB 72h
	DEFB 72h
	DEFB 65h
	DEFB 63h
	DEFB 74h
	DEFB 6Fh
__LABEL117:
	DEFW 000Dh
	DEFB 43h
	DEFB 6Fh
	DEFB 6Eh
	DEFB 65h
	DEFB 63h
	DEFB 74h
	DEFB 61h
	DEFB 6Eh
	DEFB 64h
	DEFB 6Fh
	DEFB 2Eh
	DEFB 2Eh
	DEFB 2Eh
__LABEL120:
	DEFW 001Ch
	DEFB 45h
	DEFB 72h
	DEFB 72h
	DEFB 6Fh
	DEFB 72h
	DEFB 20h
	DEFB 65h
	DEFB 6Eh
	DEFB 76h
	DEFB 69h
	DEFB 61h
	DEFB 6Eh
	DEFB 64h
	DEFB 6Fh
	DEFB 20h
	DEFB 64h
	DEFB 61h
	DEFB 74h
	DEFB 6Fh
	DEFB 73h
	DEFB 20h
	DEFB 64h
	DEFB 65h
	DEFB 20h
	DEFB 53h
	DEFB 53h
	DEFB 49h
	DEFB 44h
__LABEL123:
	DEFW 001Ch
	DEFB 45h
	DEFB 72h
	DEFB 72h
	DEFB 6Fh
	DEFB 72h
	DEFB 20h
	DEFB 65h
	DEFB 6Eh
	DEFB 76h
	DEFB 69h
	DEFB 61h
	DEFB 6Eh
	DEFB 64h
	DEFB 6Fh
	DEFB 20h
	DEFB 64h
	DEFB 61h
	DEFB 74h
	DEFB 6Fh
	DEFB 73h
	DEFB 20h
	DEFB 64h
	DEFB 65h
	DEFB 20h
	DEFB 70h
	DEFB 61h
	DEFB 73h
	DEFB 73h
__LABEL126:
	DEFW 0018h
	DEFB 45h
	DEFB 72h
	DEFB 72h
	DEFB 6Fh
	DEFB 72h
	DEFB 20h
	DEFB 69h
	DEFB 6Eh
	DEFB 69h
	DEFB 63h
	DEFB 69h
	DEFB 61h
	DEFB 6Eh
	DEFB 64h
	DEFB 6Fh
	DEFB 20h
	DEFB 63h
	DEFB 6Fh
	DEFB 6Eh
	DEFB 65h
	DEFB 78h
	DEFB 69h
	DEFB 6Fh
	DEFB 6Eh
__LABEL135:
	DEFW 0009h
	DEFB 43h
	DEFB 6Fh
	DEFB 6Eh
	DEFB 65h
	DEFB 63h
	DEFB 74h
	DEFB 61h
	DEFB 64h
	DEFB 6Fh
__LABEL136:
	DEFW 0011h
	DEFB 45h
	DEFB 72h
	DEFB 72h
	DEFB 6Fh
	DEFB 72h
	DEFB 20h
	DEFB 61h
	DEFB 6Ch
	DEFB 20h
	DEFB 63h
	DEFB 6Fh
	DEFB 6Eh
	DEFB 65h
	DEFB 63h
	DEFB 74h
	DEFB 61h
	DEFB 72h
__LABEL137:
	DEFW 0012h
	DEFB 51h
	DEFB 75h
	DEFB 65h
	DEFB 20h
	DEFB 71h
	DEFB 75h
	DEFB 69h
	DEFB 65h
	DEFB 72h
	DEFB 65h
	DEFB 73h
	DEFB 20h
	DEFB 68h
	DEFB 61h
	DEFB 63h
	DEFB 65h
	DEFB 72h
	DEFB 3Fh
__LABEL138:
	DEFW 0019h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 28h
	DEFB 72h
	DEFB 29h
	DEFB 65h
	DEFB 69h
	DEFB 6Eh
	DEFB 74h
	DEFB 65h
	DEFB 6Eh
	DEFB 74h
	DEFB 61h
	DEFB 72h
	DEFB 20h
	DEFB 63h
	DEFB 6Fh
	DEFB 6Eh
	DEFB 65h
	DEFB 78h
	DEFB 69h
	DEFB 6Fh
	DEFB 6Eh
__LABEL139:
	DEFW 000Bh
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 28h
	DEFB 73h
	DEFB 29h
	DEFB 61h
	DEFB 6Ch
	DEFB 69h
	DEFB 72h
__LABEL140:
	DEFW 0001h
	DEFB 72h
__LABEL143:
	DEFW 0001h
	DEFB 73h
__LABEL146:
	DEFW 0011h
	DEFB 4Fh
	DEFB 70h
	DEFB 63h
	DEFB 69h
	DEFB 6Fh
	DEFB 6Eh
	DEFB 20h
	DEFB 69h
	DEFB 6Eh
	DEFB 63h
	DEFB 6Fh
	DEFB 72h
	DEFB 72h
	DEFB 65h
	DEFB 63h
	DEFB 74h
	DEFB 61h
__LABEL147:
	DEFW 0015h
	DEFB 2Dh
	DEFB 43h
	DEFB 6Fh
	DEFB 6Eh
	DEFB 65h
	DEFB 63h
	DEFB 74h
	DEFB 61h
	DEFB 72h
	DEFB 20h
	DEFB 61h
	DEFB 6Ch
	DEFB 20h
	DEFB 73h
	DEFB 65h
	DEFB 72h
	DEFB 76h
	DEFB 69h
	DEFB 64h
	DEFB 6Fh
	DEFB 72h
__LABEL148:
	DEFW 0015h
	DEFB 20h
	DEFB 20h
	DEFB 49h
	DEFB 6Eh
	DEFB 64h
	DEFB 69h
	DEFB 63h
	DEFB 61h
	DEFB 20h
	DEFB 6Ch
	DEFB 61h
	DEFB 20h
	DEFB 64h
	DEFB 69h
	DEFB 72h
	DEFB 65h
	DEFB 63h
	DEFB 63h
	DEFB 69h
	DEFB 6Fh
	DEFB 6Eh
__LABEL151:
	DEFW 0013h
	DEFB 53h
	DEFB 65h
	DEFB 72h
	DEFB 76h
	DEFB 69h
	DEFB 64h
	DEFB 6Fh
	DEFB 72h
	DEFB 20h
	DEFB 69h
	DEFB 6Eh
	DEFB 63h
	DEFB 6Fh
	DEFB 72h
	DEFB 72h
	DEFB 65h
	DEFB 63h
	DEFB 74h
	DEFB 6Fh
__LABEL152:
	DEFW 0012h
	DEFB 20h
	DEFB 20h
	DEFB 49h
	DEFB 6Eh
	DEFB 64h
	DEFB 69h
	DEFB 63h
	DEFB 61h
	DEFB 20h
	DEFB 65h
	DEFB 6Ch
	DEFB 20h
	DEFB 70h
	DEFB 75h
	DEFB 65h
	DEFB 72h
	DEFB 74h
	DEFB 6Fh
__LABEL155:
	DEFW 0011h
	DEFB 50h
	DEFB 75h
	DEFB 65h
	DEFB 72h
	DEFB 74h
	DEFB 6Fh
	DEFB 20h
	DEFB 69h
	DEFB 6Eh
	DEFB 63h
	DEFB 6Fh
	DEFB 72h
	DEFB 72h
	DEFB 65h
	DEFB 63h
	DEFB 74h
	DEFB 6Fh
__LABEL160:
	DEFW 0018h
	DEFB 45h
	DEFB 72h
	DEFB 72h
	DEFB 6Fh
	DEFB 72h
	DEFB 20h
	DEFB 65h
	DEFB 6Eh
	DEFB 76h
	DEFB 69h
	DEFB 61h
	DEFB 6Eh
	DEFB 64h
	DEFB 6Fh
	DEFB 20h
	DEFB 64h
	DEFB 69h
	DEFB 72h
	DEFB 65h
	DEFB 63h
	DEFB 63h
	DEFB 69h
	DEFB 6Fh
	DEFB 6Eh
__LABEL163:
	DEFW 0015h
	DEFB 45h
	DEFB 72h
	DEFB 72h
	DEFB 6Fh
	DEFB 72h
	DEFB 20h
	DEFB 65h
	DEFB 6Eh
	DEFB 76h
	DEFB 69h
	DEFB 61h
	DEFB 6Eh
	DEFB 64h
	DEFB 6Fh
	DEFB 20h
	DEFB 70h
	DEFB 75h
	DEFB 65h
	DEFB 72h
	DEFB 74h
	DEFB 6Fh
#line 1 "alloc.asm"

; vim: ts=4:et:sw=4:
	; Copyleft (K) by Jose M. Rodriguez de la Rosa
	;  (a.k.a. Boriel)
;  http://www.boriel.com
	;
	; This ASM library is licensed under the MIT license
	; you can use it for any purpose (even for commercial
	; closed source programs).
	;
	; Please read the MIT license on the internet

	; ----- IMPLEMENTATION NOTES ------
	; The heap is implemented as a linked list of free blocks.

; Each free block contains this info:
	;
	; +----------------+ <-- HEAP START
	; | Size (2 bytes) |
	; |        0       | <-- Size = 0 => DUMMY HEADER BLOCK
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   | <-- If Size > 4, then this contains (size - 4) bytes
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+   |
	;   <Allocated>        | <-- This zone is in use (Already allocated)
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Next (2 bytes) |--> NULL => END OF LIST
	; |    0 = NULL    |
	; +----------------+
	; | <free bytes...>|
	; | (0 if Size = 4)|
	; +----------------+


	; When a block is FREED, the previous and next pointers are examined to see
	; if we can defragment the heap. If the block to be freed is just next to the
	; previous, or to the next (or both) they will be converted into a single
	; block (so defragmented).


	;   MEMORY MANAGER
	;
	; This library must be initialized calling __MEM_INIT with
	; HL = BLOCK Start & DE = Length.

	; An init directive is useful for initialization routines.
	; They will be added automatically if needed.

#line 1 "error.asm"

	; Simple error control routines
; vim:ts=4:et:

	ERR_NR    EQU    23610    ; Error code system variable


	; Error code definitions (as in ZX spectrum manual)

; Set error code with:
	;    ld a, ERROR_CODE
	;    ld (ERR_NR), a


	ERROR_Ok                EQU    -1
	ERROR_SubscriptWrong    EQU     2
	ERROR_OutOfMemory       EQU     3
	ERROR_OutOfScreen       EQU     4
	ERROR_NumberTooBig      EQU     5
	ERROR_InvalidArg        EQU     9
	ERROR_IntOutOfRange     EQU    10
	ERROR_NonsenseInBasic   EQU    11
	ERROR_InvalidFileName   EQU    14
	ERROR_InvalidColour     EQU    19
	ERROR_BreakIntoProgram  EQU    20
	ERROR_TapeLoadingErr    EQU    26


	; Raises error using RST #8
__ERROR:
	    ld (__ERROR_CODE), a
	    rst 8
__ERROR_CODE:
	    nop
	    ret

	; Sets the error system variable, but keeps running.
	; Usually this instruction if followed by the END intermediate instruction.
__STOP:
	    ld (ERR_NR), a
	    ret
#line 69 "alloc.asm"
#line 1 "heapinit.asm"

; vim: ts=4:et:sw=4:
	; Copyleft (K) by Jose M. Rodriguez de la Rosa
	;  (a.k.a. Boriel)
;  http://www.boriel.com
	;
	; This ASM library is licensed under the BSD license
	; you can use it for any purpose (even for commercial
	; closed source programs).
	;
	; Please read the BSD license on the internet

	; ----- IMPLEMENTATION NOTES ------
	; The heap is implemented as a linked list of free blocks.

; Each free block contains this info:
	;
	; +----------------+ <-- HEAP START
	; | Size (2 bytes) |
	; |        0       | <-- Size = 0 => DUMMY HEADER BLOCK
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   | <-- If Size > 4, then this contains (size - 4) bytes
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+   |
	;   <Allocated>        | <-- This zone is in use (Already allocated)
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Next (2 bytes) |--> NULL => END OF LIST
	; |    0 = NULL    |
	; +----------------+
	; | <free bytes...>|
	; | (0 if Size = 4)|
	; +----------------+


	; When a block is FREED, the previous and next pointers are examined to see
	; if we can defragment the heap. If the block to be breed is just next to the
	; previous, or to the next (or both) they will be converted into a single
	; block (so defragmented).


	;   MEMORY MANAGER
	;
	; This library must be initialized calling __MEM_INIT with
	; HL = BLOCK Start & DE = Length.

	; An init directive is useful for initialization routines.
	; They will be added automatically if needed.




	; ---------------------------------------------------------------------
	;  __MEM_INIT must be called to initalize this library with the
	; standard parameters
	; ---------------------------------------------------------------------
__MEM_INIT: ; Initializes the library using (RAMTOP) as start, and
	        ld hl, ZXBASIC_MEM_HEAP  ; Change this with other address of heap start
	        ld de, ZXBASIC_HEAP_SIZE ; Change this with your size

	; ---------------------------------------------------------------------
	;  __MEM_INIT2 initalizes this library
; Parameters:
;   HL : Memory address of 1st byte of the memory heap
;   DE : Length in bytes of the Memory Heap
	; ---------------------------------------------------------------------
__MEM_INIT2:
	        ; HL as TOP
	        PROC

	        dec de
	        dec de
	        dec de
	        dec de        ; DE = length - 4; HL = start
	        ; This is done, because we require 4 bytes for the empty dummy-header block

	        xor a
	        ld (hl), a
	        inc hl
        ld (hl), a ; First "free" block is a header: size=0, Pointer=&(Block) + 4
	        inc hl

	        ld b, h
	        ld c, l
	        inc bc
	        inc bc      ; BC = starts of next block

	        ld (hl), c
	        inc hl
	        ld (hl), b
	        inc hl      ; Pointer to next block

	        ld (hl), e
	        inc hl
	        ld (hl), d
	        inc hl      ; Block size (should be length - 4 at start); This block contains all the available memory

	        ld (hl), a ; NULL (0000h) ; No more blocks (a list with a single block)
	        inc hl
	        ld (hl), a

	        ld a, 201
	        ld (__MEM_INIT), a; "Pokes" with a RET so ensure this routine is not called again
	        ret

	        ENDP

#line 70 "alloc.asm"


	; ---------------------------------------------------------------------
	; MEM_ALLOC
	;  Allocates a block of memory in the heap.
	;
	; Parameters
	;  BC = Length of requested memory block
	;
; Returns:
	;  HL = Pointer to the allocated block in memory. Returns 0 (NULL)
	;       if the block could not be allocated (out of memory)
	; ---------------------------------------------------------------------

MEM_ALLOC:
__MEM_ALLOC: ; Returns the 1st free block found of the given length (in BC)
	        PROC

	        LOCAL __MEM_LOOP
	        LOCAL __MEM_DONE
	        LOCAL __MEM_SUBTRACT
	        LOCAL __MEM_START
	        LOCAL TEMP, TEMP0

	TEMP EQU TEMP0 + 1

	        ld hl, 0
	        ld (TEMP), hl

__MEM_START:
	        ld hl, ZXBASIC_MEM_HEAP  ; This label point to the heap start
	        inc bc
	        inc bc  ; BC = BC + 2 ; block size needs 2 extra bytes for hidden pointer

__MEM_LOOP:  ; Loads lengh at (HL, HL+). If Lenght >= BC, jump to __MEM_DONE
	        ld a, h ;  HL = NULL (No memory available?)
	        or l
#line 111 "C:/ZXBasic/library-asm/alloc.asm"
	        ret z ; NULL
#line 113 "C:/ZXBasic/library-asm/alloc.asm"
	        ; HL = Pointer to Free block
	        ld e, (hl)
	        inc hl
	        ld d, (hl)
	        inc hl          ; DE = Block Length

	        push hl         ; HL = *pointer to -> next block
	        ex de, hl
	        or a            ; CF = 0
	        sbc hl, bc      ; FREE >= BC (Length)  (HL = BlockLength - Length)
	        jp nc, __MEM_DONE
	        pop hl
	        ld (TEMP), hl

	        ex de, hl
	        ld e, (hl)
	        inc hl
	        ld d, (hl)
	        ex de, hl
	        jp __MEM_LOOP

__MEM_DONE:  ; A free block has been found.
	             ; Check if at least 4 bytes remains free (HL >= 4)
	        push hl
	        exx  ; exx to preserve bc
	        pop hl
	        ld bc, 4
	        or a
	        sbc hl, bc
	        exx
	        jp nc, __MEM_SUBTRACT
	        ; At this point...
	        ; less than 4 bytes remains free. So we return this block entirely
	        ; We must link the previous block with the next to this one
	        ; (DE) => Pointer to next block
	        ; (TEMP) => &(previous->next)
	        pop hl     ; Discard current block pointer
	        push de
	        ex de, hl  ; DE = Previous block pointer; (HL) = Next block pointer
	        ld a, (hl)
	        inc hl
	        ld h, (hl)
	        ld l, a    ; HL = (HL)
	        ex de, hl  ; HL = Previous block pointer; DE = Next block pointer
TEMP0:
	        ld hl, 0   ; Pre-previous block pointer

	        ld (hl), e
	        inc hl
	        ld (hl), d ; LINKED
	        pop hl ; Returning block.

	        ret

__MEM_SUBTRACT:
	        ; At this point we have to store HL value (Length - BC) into (DE - 2)
	        ex de, hl
	        dec hl
	        ld (hl), d
	        dec hl
	        ld (hl), e ; Store new block length

	        add hl, de ; New length + DE => free-block start
	        pop de     ; Remove previous HL off the stack

	        ld (hl), c ; Store length on its 1st word
	        inc hl
	        ld (hl), b
	        inc hl     ; Return hl
	        ret

	        ENDP

#line 3052 "ZXTelnet.zxbas"
#line 1 "asc.asm"

	; Returns the ascii code for the given str
#line 1 "free.asm"

; vim: ts=4:et:sw=4:
	; Copyleft (K) by Jose M. Rodriguez de la Rosa
	;  (a.k.a. Boriel)
;  http://www.boriel.com
	;
	; This ASM library is licensed under the BSD license
	; you can use it for any purpose (even for commercial
	; closed source programs).
	;
	; Please read the BSD license on the internet

	; ----- IMPLEMENTATION NOTES ------
	; The heap is implemented as a linked list of free blocks.

; Each free block contains this info:
	;
	; +----------------+ <-- HEAP START
	; | Size (2 bytes) |
	; |        0       | <-- Size = 0 => DUMMY HEADER BLOCK
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   | <-- If Size > 4, then this contains (size - 4) bytes
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+   |
	;   <Allocated>        | <-- This zone is in use (Already allocated)
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Next (2 bytes) |--> NULL => END OF LIST
	; |    0 = NULL    |
	; +----------------+
	; | <free bytes...>|
	; | (0 if Size = 4)|
	; +----------------+


	; When a block is FREED, the previous and next pointers are examined to see
	; if we can defragment the heap. If the block to be breed is just next to the
	; previous, or to the next (or both) they will be converted into a single
	; block (so defragmented).


	;   MEMORY MANAGER
	;
	; This library must be initialized calling __MEM_INIT with
	; HL = BLOCK Start & DE = Length.

	; An init directive is useful for initialization routines.
	; They will be added automatically if needed.



	; ---------------------------------------------------------------------
	; MEM_FREE
	;  Frees a block of memory
	;
; Parameters:
	;  HL = Pointer to the block to be freed. If HL is NULL (0) nothing
	;  is done
	; ---------------------------------------------------------------------

MEM_FREE:
__MEM_FREE: ; Frees the block pointed by HL
	            ; HL DE BC & AF modified
	        PROC

	        LOCAL __MEM_LOOP2
	        LOCAL __MEM_LINK_PREV
	        LOCAL __MEM_JOIN_TEST
	        LOCAL __MEM_BLOCK_JOIN

	        ld a, h
	        or l
	        ret z       ; Return if NULL pointer

	        dec hl
	        dec hl
	        ld b, h
	        ld c, l    ; BC = Block pointer

	        ld hl, ZXBASIC_MEM_HEAP  ; This label point to the heap start

__MEM_LOOP2:
	        inc hl
	        inc hl     ; Next block ptr

	        ld e, (hl)
	        inc hl
	        ld d, (hl) ; Block next ptr
	        ex de, hl  ; DE = &(block->next); HL = block->next

	        ld a, h    ; HL == NULL?
	        or l
	        jp z, __MEM_LINK_PREV; if so, link with previous

	        or a       ; Clear carry flag
	        sbc hl, bc ; Carry if BC > HL => This block if before
	        add hl, bc ; Restores HL, preserving Carry flag
	        jp c, __MEM_LOOP2 ; This block is before. Keep searching PASS the block

	;------ At this point current HL is PAST BC, so we must link (DE) with BC, and HL in BC->next

__MEM_LINK_PREV:    ; Link (DE) with BC, and BC->next with HL
	        ex de, hl
	        push hl
	        dec hl

	        ld (hl), c
	        inc hl
	        ld (hl), b ; (DE) <- BC

	        ld h, b    ; HL <- BC (Free block ptr)
	        ld l, c
	        inc hl     ; Skip block length (2 bytes)
	        inc hl
	        ld (hl), e ; Block->next = DE
	        inc hl
	        ld (hl), d
	        ; --- LINKED ; HL = &(BC->next) + 2

	        call __MEM_JOIN_TEST
	        pop hl

__MEM_JOIN_TEST:   ; Checks for fragmented contiguous blocks and joins them
	                   ; hl = Ptr to current block + 2
	        ld d, (hl)
	        dec hl
	        ld e, (hl)
	        dec hl
	        ld b, (hl) ; Loads block length into BC
	        dec hl
	        ld c, (hl) ;

	        push hl    ; Saves it for later
	        add hl, bc ; Adds its length. If HL == DE now, it must be joined
	        or a
	        sbc hl, de ; If Z, then HL == DE => We must join
	        pop hl
	        ret nz

__MEM_BLOCK_JOIN:  ; Joins current block (pointed by HL) with next one (pointed by DE). HL->length already in BC
	        push hl    ; Saves it for later
	        ex de, hl

	        ld e, (hl) ; DE -> block->next->length
	        inc hl
	        ld d, (hl)
	        inc hl

	        ex de, hl  ; DE = &(block->next)
	        add hl, bc ; HL = Total Length

	        ld b, h
	        ld c, l    ; BC = Total Length

	        ex de, hl
	        ld e, (hl)
	        inc hl
	        ld d, (hl) ; DE = block->next

	        pop hl     ; Recovers Pointer to block
	        ld (hl), c
	        inc hl
	        ld (hl), b ; Length Saved
	        inc hl
	        ld (hl), e
	        inc hl
	        ld (hl), d ; Next saved
	        ret

	        ENDP

#line 3 "asc.asm"

__ASC:
		PROC
		LOCAL __ASC_END

		ex af, af'	; Saves free_mem flag

		ld a, h
		or l
		ret z		; NULL? return

		ld c, (hl)
		inc hl
		ld b, (hl)

		ld a, b
		or c
		jr z, __ASC_END		; No length? return

		inc hl
		ld a, (hl)
	    dec hl

__ASC_END:
		dec hl
		ex af, af'
		or a
		call nz, __MEM_FREE	; Free memory if needed

		ex af, af'	; Recover result

		ret
		ENDP
#line 3053 "ZXTelnet.zxbas"
#line 1 "band32.asm"

	; FASTCALL bitwise and 32 version.
	; Performs 32bit and 32bit and returns the bitwise
	; result in DE,HL
	; First operand in DE,HL 2nd operand into the stack

__BAND32:
	    ld b, h
	    ld c, l ; BC <- HL

	    pop hl  ; Return address
	    ex (sp), hl ; HL <- Lower part of 2nd Operand

		ld a, b
	    and h
	    ld b, a

	    ld a, c
	    and l
	    ld c, a ; BC <- BC & HL

		pop hl  ; Return dddress
	    ex (sp), hl ; HL <- High part of 2nd Operand

	    ld a, d
	    and h
	    ld d, a

	    ld a, e
	    and l
	    ld e, a ; DE <- DE & HL

	    ld h, b
	    ld l, c ; HL <- BC  ; Always return DE,HL pair regs

	    ret

#line 3054 "ZXTelnet.zxbas"
#line 1 "bor32.asm"

	; FASTCALL bitwise or 32 version.
	; Performs 32bit or 32bit and returns the bitwise
	; result DE,HL
	; First operand in DE,HL 2nd operand into the stack

__BOR32:
	    ld b, h
	    ld c, l ; BC <- HL

	    pop hl  ; Return address
	    ex (sp), hl ; HL <- Lower part of 2nd Operand

		ld a, b
	    or h
	    ld b, a

	    ld a, c
	    or l
	    ld c, a ; BC <- BC & HL

		pop hl  ; Return dddress
	    ex (sp), hl ; HL <- High part of 2nd Operand

	    ld a, d
	    or h
	    ld d, a

	    ld a, e
	    or l
	    ld e, a ; DE <- DE & HL

	    ld h, b
	    ld l, c ; HL <- BC  ; Always return DE,HL pair regs

	    ret

#line 3055 "ZXTelnet.zxbas"
#line 1 "border.asm"

	; __FASTCALL__ Routine to change de border
	; Parameter (color) specified in A register

	BORDER EQU 229Bh

	; Nothing to do! (Directly from the ZX Spectrum ROM)

#line 3056 "ZXTelnet.zxbas"
#line 1 "bright.asm"

	; Sets bright flag in ATTR_P permanently
; Parameter: Paper color in A register

#line 1 "const.asm"

	; Global constants

	P_FLAG	EQU 23697
	FLAGS2	EQU 23681
	ATTR_P	EQU 23693	; permanet ATTRIBUTES
	ATTR_T	EQU 23695	; temporary ATTRIBUTES
	CHARS	EQU 23606 ; Pointer to ROM/RAM Charset
	UDG	EQU 23675 ; Pointer to UDG Charset
	MEM0	EQU 5C92h ; Temporary memory buffer used by ROM chars

#line 5 "bright.asm"

BRIGHT:
		ld hl, ATTR_P

	    PROC
	    LOCAL IS_TR
	    LOCAL IS_ZERO

__SET_BRIGHT:
		; Another entry. This will set the bright flag at location pointer by DE
		cp 8
		jr z, IS_TR

		; # Convert to 0/1
		or a
		jr z, IS_ZERO
		ld a, 0x40

IS_ZERO:
		ld b, a	; Saves the color
		ld a, (hl)
		and 0BFh ; Clears previous value
		or b
		ld (hl), a
		inc hl
		res 6, (hl)  ;Reset bit 6 to disable transparency
		ret

IS_TR:  ; transparent
		inc hl ; Points DE to MASK_T or MASK_P
	    set 6, (hl)  ;Set bit 6 to enable transparency
		ret

	; Sets the BRIGHT flag passed in A register in the ATTR_T variable
BRIGHT_TMP:
		ld hl, ATTR_T
		jr __SET_BRIGHT
	    ENDP
#line 3057 "ZXTelnet.zxbas"
#line 1 "chr.asm"

	; CHR$(x, y, x) returns the string CHR$(x) + CHR$(y) + CHR$(z)
	;



CHR:	; Returns HL = Pointer to STRING (NULL if no memory)
			; Requires alloc.asm for dynamic memory heap.
		; Parameters: HL = Number of bytes to insert (already push onto the stack)
			; STACK => parameters (16 bit, only the High byte is considered)
			; Used registers A, A', BC, DE, HL, H'L'

			PROC

			LOCAL __POPOUT
			LOCAL TMP

	TMP		EQU 23629 ; (DEST System variable)

			ld a, h
			or l
			ret z	; If Number of parameters is ZERO, return NULL STRING

			ld b, h
			ld c, l

			pop hl	; Return address
			ld (TMP), hl

			push bc
			inc bc
			inc bc	; BC = BC + 2 => (2 bytes for the length number)
			call __MEM_ALLOC
			pop bc

			ld d, h
			ld e, l			; Saves HL in DE

			ld a, h
			or l
			jr z, __POPOUT	; No Memory, return

			ld (hl), c
			inc hl
			ld (hl), b
			inc hl

__POPOUT:	; Removes out of the stack every byte and return
				; If Zero Flag is set, don't store bytes in memory
			ex af, af' ; Save Zero Flag

			ld a, b
			or c
			jr z, __CHR_END

			dec bc
			pop af 	   ; Next byte

			ex af, af' ; Recovers Zero flag
			jr z, __POPOUT

			ex af, af' ; Saves Zero flag
			ld (hl), a
			inc hl
	        ex af, af' ; Recovers Zero Flag

			jp __POPOUT

__CHR_END:
			ld hl, (TMP)
			push hl		; Restores return addr
			ex de, hl	; Recovers original HL ptr
			ret

			ENDP

#line 3058 "ZXTelnet.zxbas"
#line 1 "cls.asm"

	; JUMPS directly to spectrum CLS
	; This routine does not clear lower screen

	;CLS	EQU	0DAFh

	; Our faster implementation

#line 1 "sposn.asm"

	; Printing positioning library.
			PROC
			LOCAL ECHO_E

__LOAD_S_POSN:		; Loads into DE current ROW, COL print position from S_POSN mem var.
			ld de, (S_POSN)
			ld hl, (MAXX)
			or a
			sbc hl, de
			ex de, hl
			ret


__SAVE_S_POSN:		; Saves ROW, COL from DE into S_POSN mem var.
			ld hl, (MAXX)
			or a
			sbc hl, de
			ld (S_POSN), hl ; saves it again
			ret


	ECHO_E	EQU 23682
	MAXX	EQU ECHO_E   ; Max X position + 1
	MAXY	EQU MAXX + 1 ; Max Y position + 1

	S_POSN	EQU 23688
	POSX	EQU S_POSN		; Current POS X
	POSY	EQU S_POSN + 1	; Current POS Y

			ENDP

#line 9 "cls.asm"

CLS:
		PROC

		LOCAL COORDS
		LOCAL __CLS_SCR
		LOCAL ATTR_P
		LOCAL SCREEN

		ld hl, 0
		ld (COORDS), hl
	    ld hl, 1821h
		ld (S_POSN), hl
__CLS_SCR:
		ld hl, SCREEN
		ld (hl), 0
		ld d, h
		ld e, l
		inc de
		ld bc, 6144
		ldir

		; Now clear attributes

		ld a, (ATTR_P)
		ld (hl), a
		ld bc, 767
		ldir
		ret

	COORDS	EQU	23677
	SCREEN	EQU 16384 ; Default start of the screen (can be changed)
	ATTR_P	EQU 23693
	;you can poke (SCREEN_SCRADDR) to change CLS, DRAW & PRINTing address

	SCREEN_ADDR EQU (__CLS_SCR + 1) ; Address used by print and other screen routines
								    ; to get the start of the screen
		ENDP

#line 3059 "ZXTelnet.zxbas"
#line 1 "copy_attr.asm"

#line 4 "C:/ZXBasic/library-asm/copy_attr.asm"



COPY_ATTR:
		; Just copies current permanent attribs to temporal attribs
		; and sets print mode
		PROC

		LOCAL INVERSE1
		LOCAL __REFRESH_TMP

	INVERSE1 EQU 02Fh

		ld hl, (ATTR_P)
		ld (ATTR_T), hl

		ld hl, FLAGS2
		call __REFRESH_TMP

		ld hl, P_FLAG
		call __REFRESH_TMP


__SET_ATTR_MODE:		; Another entry to set print modes. A contains (P_FLAG)

#line 63 "C:/ZXBasic/library-asm/copy_attr.asm"
		ret
#line 65 "C:/ZXBasic/library-asm/copy_attr.asm"

__REFRESH_TMP:
		ld a, (hl)
		and 10101010b
		ld c, a
		rra
		or c
		ld (hl), a
		ret

		ENDP

#line 3060 "ZXTelnet.zxbas"
#line 1 "eq16.asm"

__EQ16:	; Test if 16bit values HL == DE
		; Returns result in A: 0 = False, FF = True
			xor a	; Reset carry flag
			sbc hl, de
			ret nz
			inc a
			ret

#line 3061 "ZXTelnet.zxbas"


#line 1 "ftou32reg.asm"

#line 1 "neg32.asm"

__ABS32:
		bit 7, d
		ret z

__NEG32: ; Negates DEHL (Two's complement)
		ld a, l
		cpl
		ld l, a

		ld a, h
		cpl
		ld h, a

		ld a, e
		cpl
		ld e, a

		ld a, d
		cpl
		ld d, a

		inc l
		ret nz

		inc h
		ret nz

		inc de
		ret

#line 2 "ftou32reg.asm"

__FTOU32REG:	; Converts a Float to (un)signed 32 bit integer (NOTE: It's ALWAYS 32 bit signed)
					; Input FP number in A EDCB (A exponent, EDCB mantissa)
				; Output: DEHL 32 bit number (signed)
		PROC

		LOCAL __IS_FLOAT
		LOCAL __NEGATE

		or a
		jr nz, __IS_FLOAT
		; Here if it is a ZX ROM Integer

		ld h, c
		ld l, d
	ld a, e	 ; Takes sign: FF = -, 0 = +
		ld de, 0
		inc a
		jp z, __NEG32	; Negates if negative
		ret

__IS_FLOAT:  ; Jumps here if it is a true floating point number
		ld h, e
		push hl  ; Stores it for later (Contains Sign in H)

		push de
		push bc

		exx
		pop de   ; Loads mantissa into C'B' E'D'
		pop bc	 ;

		set 7, c ; Highest mantissa bit is always 1
		exx

		ld hl, 0 ; DEHL = 0
		ld d, h
		ld e, l

		;ld a, c  ; Get exponent
		sub 128  ; Exponent -= 128
		jr z, __FTOU32REG_END	; If it was <= 128, we are done (Integers must be > 128)
		jr c, __FTOU32REG_END	; It was decimal (0.xxx). We are done (return 0)

		ld b, a  ; Loop counter = exponent - 128

__FTOU32REG_LOOP:
		exx 	 ; Shift C'B' E'D' << 1, output bit stays in Carry
		sla d
		rl e
		rl b
		rl c

	    exx		 ; Shift DEHL << 1, inserting the carry on the right
		rl l
		rl h
		rl e
		rl d

		djnz __FTOU32REG_LOOP

__FTOU32REG_END:
		pop af   ; Take the sign bit
		or a	 ; Sets SGN bit to 1 if negative
		jp m, __NEGATE ; Negates DEHL

		ret

__NEGATE:
	    exx
	    ld a, d
	    or e
	    or b
	    or c
	    exx
	    jr z, __END
	    inc l
	    jr nz, __END
	    inc h
	    jr nz, __END
	    inc de
	LOCAL __END
__END:
	    jp __NEG32
		ENDP


__FTOU8:	; Converts float in C ED LH to Unsigned byte in A
		call __FTOU32REG
		ld a, l
		ret

#line 3064 "ZXTelnet.zxbas"
#line 1 "iload32.asm"

	; __FASTCALL__ routine which
	; loads a 32 bits integer into DE,HL
	; stored at position pointed by POINTER HL
	; DE,HL <-- (HL)

__ILOAD32:
		ld e, (hl)
		inc hl
		ld d, (hl)
		inc hl
		ld a, (hl)
		inc hl
		ld h, (hl)
		ld l, a
		ex de, hl
		ret

#line 3065 "ZXTelnet.zxbas"
#line 1 "ink.asm"

	; Sets ink color in ATTR_P permanently
; Parameter: Paper color in A register



INK:
		PROC
		LOCAL __SET_INK
		LOCAL __SET_INK2

		ld de, ATTR_P

__SET_INK:
		cp 8
		jr nz, __SET_INK2

		inc de ; Points DE to MASK_T or MASK_P
		ld a, (de)
		or 7 ; Set bits 0,1,2 to enable transparency
		ld (de), a
		ret

__SET_INK2:
		; Another entry. This will set the ink color at location pointer by DE
		and 7	; # Gets color mod 8
		ld b, a	; Saves the color
		ld a, (de)
		and 0F8h ; Clears previous value
		or b
		ld (de), a
		inc de ; Points DE to MASK_T or MASK_P
		ld a, (de)
		and 0F8h ; Reset bits 0,1,2 sign to disable transparency
		ld (de), a ; Store new attr
		ret

	; Sets the INK color passed in A register in the ATTR_T variable
INK_TMP:
		ld de, ATTR_T
		jp __SET_INK

		ENDP

#line 3066 "ZXTelnet.zxbas"
#line 1 "inkey.asm"

	; INKEY Function
	; Returns a string allocated in dynamic memory
	; containing the string.
	; An empty string otherwise.



INKEY:
		PROC
		LOCAL __EMPTY_INKEY
		LOCAL KEY_SCAN
		LOCAL KEY_TEST
		LOCAL KEY_CODE

		ld bc, 3	; 1 char length string
		call __MEM_ALLOC

		ld a, h
		or l
		ret z	; Return if NULL (No memory)

		push hl ; Saves memory pointer

		call KEY_SCAN
		jp nz, __EMPTY_INKEY

		call KEY_TEST
		jp nc, __EMPTY_INKEY

		dec d	; D is expected to be FLAGS so set bit 3 $FF
				; 'L' Mode so no keywords.
		ld e, a	; main key to A
				; C is MODE 0 'KLC' from above still.
		call KEY_CODE ; routine K-DECODE
		pop hl

		ld (hl), 1
		inc hl
		ld (hl), 0
		inc hl
		ld (hl), a
		dec hl
		dec hl	; HL Points to string result
		ret

__EMPTY_INKEY:
		pop hl
		xor a
		ld (hl), a
		inc hl
		ld (hl), a
		dec hl
		ret

	KEY_SCAN	EQU 028Eh
	KEY_TEST	EQU 031Eh
	KEY_CODE	EQU 0333h

		ENDP

#line 3067 "ZXTelnet.zxbas"
#line 1 "loadstr.asm"



	; Loads a string (ptr) from HL
	; and duplicates it on dynamic memory again
	; Finally, it returns result pointer in HL

__ILOADSTR:		; This is the indirect pointer entry HL = (HL)
			ld a, h
			or l
			ret z
			ld a, (hl)
			inc hl
			ld h, (hl)
			ld l, a

__LOADSTR:		; __FASTCALL__ entry
			ld a, h
			or l
			ret z	; Return if NULL

			ld c, (hl)
			inc hl
			ld b, (hl)
			dec hl  ; BC = LEN(a$)

			inc bc
			inc bc	; BC = LEN(a$) + 2 (two bytes for length)

			push hl
			push bc
			call __MEM_ALLOC
			pop bc  ; Recover length
			pop de  ; Recover origin

			ld a, h
			or l
			ret z	; Return if NULL (No memory)

			ex de, hl ; ldir takes HL as source, DE as destiny, so SWAP HL,DE
			push de	; Saves destiny start
			ldir	; Copies string (length number included)
			pop hl	; Recovers destiny in hl as result
			ret
#line 3068 "ZXTelnet.zxbas"
#line 1 "lti8.asm"

#line 1 "lei8.asm"

__LEI8: ; Signed <= comparison for 8bit int
	        ; A <= H (registers)
	    PROC
	    LOCAL checkParity
	    sub h
	    jr nz, __LTI
	    inc a
	    ret

__LTI8:  ; Test 8 bit values A < H
	    sub h

__LTI:   ; Generic signed comparison
	    jp po, checkParity
	    xor 0x80
checkParity:
	    ld a, 0     ; False
	    ret p
	    inc a       ; True
	    ret
	    ENDP
#line 2 "lti8.asm"
#line 3069 "ZXTelnet.zxbas"
#line 1 "over.asm"

	; Sets OVER flag in P_FLAG permanently
; Parameter: OVER flag in bit 0 of A register



OVER:
		PROC

		ld c, a ; saves it for later
		and 2
		ld hl, FLAGS2
		res 1, (HL)
		or (hl)
		ld (hl), a

		ld a, c	; Recovers previous value
		and 1	; # Convert to 0/1
		add a, a; # Shift left 1 bit for permanent

		ld hl, P_FLAG
		res 1, (hl)
		or (hl)
		ld (hl), a
		ret

	; Sets OVER flag in P_FLAG temporarily
OVER_TMP:
		ld c, a ; saves it for later
		and 2	; gets bit 1; clears carry
		rra
		ld hl, FLAGS2
		res 0, (hl)
		or (hl)
		ld (hl), a

		ld a, c	; Recovers previous value
		and 1
		ld hl, P_FLAG
		res 0, (hl)
	    or (hl)
		ld (hl), a
		jp __SET_ATTR_MODE

		ENDP

#line 3070 "ZXTelnet.zxbas"
#line 1 "paper.asm"

	; Sets paper color in ATTR_P permanently
; Parameter: Paper color in A register



PAPER:
		PROC
		LOCAL __SET_PAPER
		LOCAL __SET_PAPER2

		ld de, ATTR_P

__SET_PAPER:
		cp 8
		jr nz, __SET_PAPER2
		inc de
		ld a, (de)
		or 038h
		ld (de), a
		ret

		; Another entry. This will set the paper color at location pointer by DE
__SET_PAPER2:
		and 7	; # Remove
		rlca
		rlca
		rlca		; a *= 8

		ld b, a	; Saves the color
		ld a, (de)
		and 0C7h ; Clears previous value
		or b
		ld (de), a
		inc de ; Points to MASK_T or MASK_P accordingly
		ld a, (de)
		and 0C7h  ; Resets bits 3,4,5
		ld (de), a
		ret


	; Sets the PAPER color passed in A register in the ATTR_T variable
PAPER_TMP:
		ld de, ATTR_T
		jp __SET_PAPER
		ENDP

#line 3071 "ZXTelnet.zxbas"
#line 1 "pause.asm"

	; The PAUSE statement (Calling the ROM)

__PAUSE:
		ld b, h
	    ld c, l
	    jp 1F3Dh  ; PAUSE_1
#line 3072 "ZXTelnet.zxbas"
#line 1 "pistore32.asm"

#line 1 "store32.asm"

__PISTORE32:
			push hl
			push ix
			pop hl
			add hl, bc
			pop bc

__ISTORE32:  ; Load address at hl, and stores E,D,B,C integer at that address
			ld a, (hl)
			inc hl
			ld h, (hl)
			ld l, a

__STORE32:	; Stores the given integer in DEBC at address HL
			ld (hl), c
			inc hl
			ld (hl), b
			inc hl
			ld (hl), e
			inc hl
			ld (hl), d
			ret

#line 2 "pistore32.asm"

	; The content of this file has been moved to "store32.asm"
#line 3073 "ZXTelnet.zxbas"
#line 1 "pstore32.asm"



	; Stores a 32 bit integer number (DE,HL) at (IX + BC)
__PSTORE32:
			push hl
			push ix
			pop hl
			add hl, bc
			pop bc
			jp __STORE32
#line 3074 "ZXTelnet.zxbas"
#line 1 "pstorestr.asm"

; vim:ts=4:et:sw=4
	;
	; Stores an string (pointer to the HEAP by DE) into the address pointed
	; by (IX + BC). A new copy of the string is created into the HEAP
	;

#line 1 "storestr.asm"

; vim:ts=4:et:sw=4
	; Stores value of current string pointed by DE register into address pointed by HL
	; Returns DE = Address pointer  (&a$)
	; Returns HL = HL               (b$ => might be needed later to free it from the heap)
	;
	; e.g. => HL = _variableName    (DIM _variableName$)
	;         DE = Address into the HEAP
	;
	; This function will resize (REALLOC) the space pointed by HL
	; before copying the content of b$ into a$


#line 1 "strcpy.asm"

#line 1 "realloc.asm"

; vim: ts=4:et:sw=4:
	; Copyleft (K) by Jose M. Rodriguez de la Rosa
	;  (a.k.a. Boriel)
;  http://www.boriel.com
	;
	; This ASM library is licensed under the BSD license
	; you can use it for any purpose (even for commercial
	; closed source programs).
	;
	; Please read the BSD license on the internet

	; ----- IMPLEMENTATION NOTES ------
	; The heap is implemented as a linked list of free blocks.

; Each free block contains this info:
	;
	; +----------------+ <-- HEAP START
	; | Size (2 bytes) |
	; |        0       | <-- Size = 0 => DUMMY HEADER BLOCK
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   | <-- If Size > 4, then this contains (size - 4) bytes
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+   |
	;   <Allocated>        | <-- This zone is in use (Already allocated)
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Next (2 bytes) |--> NULL => END OF LIST
	; |    0 = NULL    |
	; +----------------+
	; | <free bytes...>|
	; | (0 if Size = 4)|
	; +----------------+


	; When a block is FREED, the previous and next pointers are examined to see
	; if we can defragment the heap. If the block to be breed is just next to the
	; previous, or to the next (or both) they will be converted into a single
	; block (so defragmented).


	;   MEMORY MANAGER
	;
	; This library must be initialized calling __MEM_INIT with
	; HL = BLOCK Start & DE = Length.

	; An init directive is useful for initialization routines.
	; They will be added automatically if needed.







	; ---------------------------------------------------------------------
	; MEM_REALLOC
	;  Reallocates a block of memory in the heap.
	;
	; Parameters
	;  HL = Pointer to the original block
	;  BC = New Length of requested memory block
	;
; Returns:
	;  HL = Pointer to the allocated block in memory. Returns 0 (NULL)
	;       if the block could not be allocated (out of memory)
	;
; Notes:
	;  If BC = 0, the block is freed, otherwise
	;  the content of the original block is copied to the new one, and
	;  the new size is adjusted. If BC < original length, the content
	;  will be truncated. Otherwise, extra block content might contain
	;  memory garbage.
	;
	; ---------------------------------------------------------------------
__REALLOC:    ; Reallocates block pointed by HL, with new length BC
	        PROC

	        LOCAL __REALLOC_END

	        ld a, h
	        or l
	        jp z, __MEM_ALLOC    ; If HL == NULL, just do a malloc

	        ld e, (hl)
	        inc hl
	        ld d, (hl)    ; DE = First 2 bytes of HL block

	        push hl
	        exx
	        pop de
	        inc de        ; DE' <- HL + 2
	        exx            ; DE' <- HL (Saves current pointer into DE')

	        dec hl        ; HL = Block start

	        push de
	        push bc
	        call __MEM_FREE        ; Frees current block
	        pop bc
	        push bc
	        call __MEM_ALLOC    ; Gets a new block of length BC
	        pop bc
	        pop de

	        ld a, h
	        or l
	        ret z        ; Return if HL == NULL (No memory)

	        ld (hl), e
	        inc hl
	        ld (hl), d
	        inc hl        ; Recovers first 2 bytes in HL

	        dec bc
	        dec bc        ; BC = BC - 2 (Two bytes copied)

	        ld a, b
	        or c
	        jp z, __REALLOC_END        ; Ret if nothing to copy (BC == 0)

	        exx
	        push de
	        exx
	        pop de        ; DE <- DE' ; Start of remaining block

	        push hl        ; Saves current Block + 2 start
        ex de, hl    ; Exchanges them: DE is destiny block
	        ldir        ; Copies BC Bytes
	        pop hl        ; Recovers Block + 2 start

__REALLOC_END:

	        dec hl        ; Set HL
	        dec hl        ; To begin of block
	        ret

	        ENDP

#line 2 "strcpy.asm"

	; String library


__STRASSIGN: ; Performs a$ = b$ (HL = address of a$; DE = Address of b$)
			PROC

			LOCAL __STRREALLOC
			LOCAL __STRCONTINUE
			LOCAL __B_IS_NULL
			LOCAL __NOTHING_TO_COPY

			ld b, d
			ld c, e
			ld a, b
			or c
			jr z, __B_IS_NULL

			ex de, hl
			ld c, (hl)
			inc hl
			ld b, (hl)
			dec hl		; BC = LEN(b$)
			ex de, hl	; DE = &b$

__B_IS_NULL:		; Jumps here if B$ pointer is NULL
			inc bc
			inc bc		; BC = BC + 2  ; (LEN(b$) + 2 bytes for storing length)

			push de
			push hl

			ld a, h
			or l
			jr z, __STRREALLOC

			dec hl
			ld d, (hl)
			dec hl
			ld e, (hl)	; DE = MEMBLOCKSIZE(a$)
			dec de
			dec de		; DE = DE - 2  ; (Membloksize takes 2 bytes for memblock length)

			ld h, b
			ld l, c		; HL = LEN(b$) + 2  => Minimum block size required
			ex de, hl	; Now HL = BLOCKSIZE(a$), DE = LEN(b$) + 2

			or a		; Prepare to subtract BLOCKSIZE(a$) - LEN(b$)
			sbc hl, de  ; Carry if len(b$) > Blocklen(a$)
			jr c, __STRREALLOC ; No need to realloc
			; Need to reallocate at least to len(b$) + 2
			ex de, hl	; DE = Remaining bytes in a$ mem block.
			ld hl, 4
			sbc hl, de  ; if remaining bytes < 4 we can continue
			jr nc,__STRCONTINUE ; Otherwise, we realloc, to free some bytes

__STRREALLOC:
			pop hl
			call __REALLOC	; Returns in HL a new pointer with BC bytes allocated
			push hl

__STRCONTINUE:	;   Pops hl and de SWAPPED
			pop de	;	DE = &a$
			pop hl	; 	HL = &b$

			ld a, d		; Return if not enough memory for new length
			or e
			ret z		; Return if DE == NULL (0)

__STRCPY:	; Copies string pointed by HL into string pointed by DE
				; Returns DE as HL (new pointer)
			ld a, h
			or l
			jr z, __NOTHING_TO_COPY
			ld c, (hl)
			inc hl
			ld b, (hl)
			dec hl
			inc bc
			inc bc
			push de
			ldir
			pop hl
			ret

__NOTHING_TO_COPY:
			ex de, hl
			ld (hl), e
			inc hl
			ld (hl), d
			dec hl
			ret

			ENDP

#line 14 "storestr.asm"

__PISTORE_STR:          ; Indirect assignement at (IX + BC)
	    push ix
	    pop hl
	    add hl, bc

__ISTORE_STR:           ; Indirect assignement, hl point to a pointer to a pointer to the heap!
	    ld c, (hl)
	    inc hl
	    ld h, (hl)
	    ld l, c             ; HL = (HL)

__STORE_STR:
	    push de             ; Pointer to b$
	    push hl             ; Array pointer to variable memory address

	    ld c, (hl)
	    inc hl
	    ld h, (hl)
	    ld l, c             ; HL = (HL)

	    call __STRASSIGN    ; HL (a$) = DE (b$); HL changed to a new dynamic memory allocation
	    ex de, hl           ; DE = new address of a$
	    pop hl              ; Recover variable memory address pointer

	    ld (hl), e
	    inc hl
	    ld (hl), d          ; Stores a$ ptr into elemem ptr

	    pop hl              ; Returns ptr to b$ in HL (Caller might needed to free it from memory)
	    ret

#line 8 "pstorestr.asm"

__PSTORE_STR:
	    push ix
	    pop hl
	    add hl, bc
	    jp __STORE_STR

#line 3075 "ZXTelnet.zxbas"
#line 1 "pstorestr2.asm"

; vim:ts=4:et:sw=4
	;
	; Stores an string (pointer to the HEAP by DE) into the address pointed
	; by (IX + BC). No new copy of the string is created into the HEAP, since
	; it's supposed it's already created (temporary string)
	;

#line 1 "storestr2.asm"

	; Similar to __STORE_STR, but this one is called when
	; the value of B$ if already duplicated onto the stack.
	; So we needn't call STRASSING to create a duplication
	; HL = address of string memory variable
	; DE = address of 2n string. It just copies DE into (HL)
	; 	freeing (HL) previously.



__PISTORE_STR2: ; Indirect store temporary string at (IX + BC)
	    push ix
	    pop hl
	    add hl, bc

__ISTORE_STR2:
		ld c, (hl)  ; Dereferences HL
		inc hl
		ld h, (hl)
		ld l, c		; HL = *HL (real string variable address)

__STORE_STR2:
		push hl
		ld c, (hl)
		inc hl
		ld h, (hl)
		ld l, c		; HL = *HL (real string address)

		push de
		call __MEM_FREE
		pop de

		pop hl
		ld (hl), e
		inc hl
		ld (hl), d
		dec hl		; HL points to mem address variable. This might be useful in the future.

		ret

#line 9 "pstorestr2.asm"

__PSTORE_STR2:
	    push ix
	    pop hl
	    add hl, bc
	    jp __STORE_STR2

#line 3076 "ZXTelnet.zxbas"
#line 1 "shl32.asm"


__SHL32: ; Left Logical Shift 32 bits

		sla l
		rl h
		rl e
		rl d
	    ret

#line 3077 "ZXTelnet.zxbas"
#line 1 "shrl32.asm"


__SHRL32: ; Right Logical Shift 32 bits

	    srl d
	    rr e
	    rr h
	    rr l
	    ret

#line 3078 "ZXTelnet.zxbas"



#line 1 "str.asm"

	; The STR$( ) BASIC function implementation

	; Given a FP number in C ED LH
	; Returns a pointer (in HL) to the memory heap
	; containing the FP number string representation


#line 1 "stackf.asm"

	; -------------------------------------------------------------
	; Functions to manage FP-Stack of the ZX Spectrum ROM CALC
	; -------------------------------------------------------------


	__FPSTACK_PUSH EQU 2AB6h	; Stores an FP number into the ROM FP stack (A, ED CB)
	__FPSTACK_POP  EQU 2BF1h	; Pops an FP number out of the ROM FP stack (A, ED CB)

__FPSTACK_PUSH2: ; Pushes Current A ED CB registers and top of the stack on (SP + 4)
	                 ; Second argument to push into the stack calculator is popped out of the stack
	                 ; Since the caller routine also receives the parameters into the top of the stack
	                 ; four bytes must be removed from SP before pop them out

	    call __FPSTACK_PUSH ; Pushes A ED CB into the FP-STACK
	    exx
	    pop hl       ; Caller-Caller return addr
	    exx
	    pop hl       ; Caller return addr

	    pop af
	    pop de
	    pop bc

	    push hl      ; Caller return addr
	    exx
	    push hl      ; Caller-Caller return addr
	    exx

	    jp __FPSTACK_PUSH


__FPSTACK_I16:	; Pushes 16 bits integer in HL into the FP ROM STACK
					; This format is specified in the ZX 48K Manual
					; You can push a 16 bit signed integer as
					; 0 SS LL HH 0, being SS the sign and LL HH the low
					; and High byte respectively
		ld a, h
		rla			; sign to Carry
		sbc	a, a	; 0 if positive, FF if negative
		ld e, a
		ld d, l
		ld c, h
		xor a
		ld b, a
		jp __FPSTACK_PUSH
#line 9 "str.asm"


__STR:

__STR_FAST:

		PROC
		LOCAL __STR_END
		LOCAL RECLAIM2
		LOCAL STK_END

		ld hl, (STK_END)
		push hl; Stores STK_END
		ld hl, (ATTR_T)	; Saves ATTR_T since it's changed by STR$ due to a ROM BUG
		push hl

	    call __FPSTACK_PUSH ; Push number into stack
		rst 28h		; # Rom Calculator
		defb 2Eh	; # STR$(x)
		defb 38h	; # END CALC
		call __FPSTACK_POP ; Recovers string parameters to A ED CB (Only ED LH are important)

		pop hl
		ld (ATTR_T), hl	; Restores ATTR_T
		pop hl
		ld (STK_END), hl	; Balance STK_END to avoid STR$ bug

		push bc
		push de

		inc bc
		inc bc
		call __MEM_ALLOC ; HL Points to new block

		pop de
		pop bc

		push hl
		ld a, h
		or l
		jr z, __STR_END  ; Return if NO MEMORY (NULL)

		push bc
		push de
		ld (hl), c
		inc hl
		ld (hl), b
		inc hl		; Copies length

		ex de, hl	; HL = start of original string
		ldir		; Copies string content

		pop de		; Original (ROM-CALC) string
		pop bc		; Original Length

__STR_END:
		ex de, hl
		inc bc

		call RECLAIM2 ; Frees TMP Memory
		pop hl		  ; String result

		ret

	RECLAIM2 EQU 19E8h
	STK_END EQU 5C65h

		ENDP

#line 3082 "ZXTelnet.zxbas"
#line 1 "strcat.asm"


#line 1 "strlen.asm"

	; Returns len if a string
	; If a string is NULL, its len is also 0
	; Result returned in HL

__STRLEN:	; Direct FASTCALL entry
			ld a, h
			or l
			ret z

			ld a, (hl)
			inc hl
			ld h, (hl)  ; LEN(str) in HL
			ld l, a
			ret


#line 3 "strcat.asm"

__ADDSTR:	; Implements c$ = a$ + b$
				; hl = &a$, de = &b$ (pointers)


__STRCAT2:	; This routine creates a new string in dynamic space
				; making room for it. Then copies a$ + b$ into it.
				; HL = a$, DE = b$

			PROC

			LOCAL __STR_CONT
			LOCAL __STRCATEND

			push hl
			call __STRLEN
			ld c, l
			ld b, h		; BC = LEN(a$)
			ex (sp), hl ; (SP) = LEN (a$), HL = a$
			push hl		; Saves pointer to a$

			inc bc
			inc bc		; +2 bytes to store length

			ex de, hl
			push hl
			call __STRLEN
			; HL = len(b$)

			add hl, bc	; Total str length => 2 + len(a$) + len(b$)

			ld c, l
			ld b, h		; BC = Total str length + 2
			call __MEM_ALLOC
			pop de		; HL = c$, DE = b$

			ex de, hl	; HL = b$, DE = c$
			ex (sp), hl ; HL = a$, (SP) = b$

			exx
			pop de		; D'E' = b$
			exx

			pop bc		; LEN(a$)

			ld a, d
			or e
		ret z		; If no memory: RETURN

__STR_CONT:
			push de		; Address of c$

			ld a, h
			or l
			jr nz, __STR_CONT1 ; If len(a$) != 0 do copy

	        ; a$ is NULL => uses HL = DE for transfer
			ld h, d
			ld l, e
			ld (hl), a	; This will copy 00 00 at (DE) location
	        inc de      ;
	        dec bc      ; Ensure BC will be set to 1 in the next step

__STR_CONT1:        ; Copies a$ (HL) into c$ (DE)
			inc bc
			inc bc		; BC = BC + 2
		ldir		; MEMCOPY: c$ = a$
			pop hl		; HL = c$

			exx
			push de		; Recovers b$; A ex hl,hl' would be very handy
			exx

			pop de		; DE = b$

__STRCAT: ; ConCATenate two strings a$ = a$ + b$. HL = ptr to a$, DE = ptr to b$
		  ; NOTE: Both DE, BC and AF are modified and lost
			  ; Returns HL (pointer to a$)
			  ; a$ Must be NOT NULL
			ld a, d
			or e
			ret z		; Returns if de is NULL (nothing to copy)

			push hl		; Saves HL to return it later

			ld c, (hl)
			inc hl
			ld b, (hl)
			inc hl
			add hl, bc	; HL = end of (a$) string ; bc = len(a$)
			push bc		; Saves LEN(a$) for later

			ex de, hl	; DE = end of string (Begin of copy addr)
			ld c, (hl)
			inc hl
			ld b, (hl)	; BC = len(b$)

			ld a, b
			or c
			jr z, __STRCATEND; Return if len(b$) == 0

			push bc			 ; Save LEN(b$)
			inc hl			 ; Skip 2nd byte of len(b$)
			ldir			 ; Concatenate b$

			pop bc			 ; Recovers length (b$)
			pop hl			 ; Recovers length (a$)
			add hl, bc		 ; HL = LEN(a$) + LEN(b$) = LEN(a$+b$)
			ex de, hl		 ; DE = LEN(a$+b$)
			pop hl

			ld (hl), e		 ; Updates new LEN and return
			inc hl
			ld (hl), d
			dec hl
			ret

__STRCATEND:
			pop hl		; Removes Len(a$)
			pop hl		; Restores original HL, so HL = a$
			ret

			ENDP

#line 3083 "ZXTelnet.zxbas"
#line 1 "string.asm"

	; String library



__STR_ISNULL:	; Returns A = FF if HL is 0, 0 otherwise
			ld a, h
			or l
			sub 1		; Only CARRY if HL is NULL
			sbc a, a	; Only FF if HL is NULL (0 otherwise)
			ret


__STRCMP:	; Compares strings at HL, DE: Returns 0 if EQual, -1 if HL < DE, +1 if HL > DE
				; A register is preserved and returned in A'
			PROC ; __FASTCALL__

			LOCAL __STRCMPZERO
			LOCAL __STRCMPEXIT
			LOCAL __STRCMPLOOP
			LOCAL __NOPRESERVEBC
			LOCAL __EQULEN
			LOCAL __EQULEN1
			LOCAL __HLZERO

			ex af, af'	; Saves current A register in A' (it's used by STRXX comparison functions)

			ld a, h
			or l
			jr z, __HLZERO

			ld a, d
			or e
			ld a, 1
			ret z		; Returns +1 if HL is not NULL and DE is NULL

			ld c, (hl)
			inc hl
			ld b, (hl)
			inc hl		; BC = LEN(a$)
			push hl		; HL = &a$, saves it

			ex de, hl
			ld e, (hl)
			inc hl
			ld d, (hl)
			inc hl
			ex de, hl	; HL = LEN(b$), de = &b$

			; At this point Carry is cleared, and A reg. = 1
			sbc hl, bc	; Carry if len(b$) > len(a$)
			jr z, __EQULEN	; Jump if they have the same length so A reg. = 0
			jr c, __EQULEN1 ; Jump if len(b$) > len(a$) so A reg. = 1
__NOPRESERVEBC:
			add hl, bc	; Restore HL (original length)
			ld b, h		; len(b$) <= len(a$)
			ld c, l		; so BC = hl
			dec a		; At this point A register = 0, it must be -1 since len(a$) > len(b$)
__EQULEN:
			dec a		; A = 0 if len(a$) = len(b$), -1 otherwise
__EQULEN1:
			pop hl		; Recovers A$ pointer
			push af		; Saves A for later (Value to return if strings reach the end)
	        ld a, b
	        or c
	        jr z, __STRCMPZERO ; empty string being compared

		; At this point: BC = lesser length, DE and HL points to b$ and a$ chars respectively
__STRCMPLOOP:
			ld a, (de)
			cpi
			jr nz, __STRCMPEXIT ; (HL) != (DE). Examine carry
			jp po, __STRCMPZERO ; END of string (both are equal)
			inc de
			jp __STRCMPLOOP

__STRCMPZERO:
			pop af		; This is -1 if len(a$) < len(b$), +1 if len(b$) > len(a$), 0 otherwise
			ret

__STRCMPEXIT:		; Sets A with the following value
			dec hl		; Get back to the last char
			cp (hl)
			sbc a, a	; A = -1 if carry => (DE) < (HL); 0 otherwise (DE) > (HL)
			cpl			; A = -1 if (HL) < (DE), 0 otherwise
			add a, a    ; A = A * 2 (thus -2 or 0)
			inc a		; A = A + 1 (thus -1 or 1)

			pop bc		; Discard top of the stack
			ret

__HLZERO:
			or d
			or e
			ret z		; Returns 0 (EQ) if HL == DE == NULL
			ld a, -1
			ret			; Returns -1 if HL is NULL and DE is not NULL

			ENDP

			; The following routines perform string comparison operations (<, >, ==, etc...)
			; On return, A will contain 0 for False, other value for True
			; Register A' will determine whether the incoming strings (HL, DE) will be freed
		; from dynamic memory on exit:
			;		Bit 0 => 1 means HL will be freed.
			;		Bit 1 => 1 means DE will be freed.

__STREQ:	; Compares a$ == b$ (HL = ptr a$, DE = ptr b$). Returns FF (True) or 0 (False)
			push hl
			push de
			call __STRCMP
			pop de
			pop hl

			;inc a		; If A == -1, return 0
			;jp z, __FREE_STR

			;dec a		;
			;dec a		; Return -1 if a = 0 (True), returns 0 if A == 1 (False)
	        sub 1
	        sbc a, a
			jp __FREE_STR


__STRNE:	; Compares a$ != b$ (HL = ptr a$, DE = ptr b$). Returns FF (True) or 0 (False)
			push hl
			push de
			call __STRCMP
			pop de
			pop hl

			;jp z, __FREE_STR

			;ld a, 0FFh	; Returns 0xFFh (True)
			jp __FREE_STR


__STRLT:	; Compares a$ < b$ (HL = ptr a$, DE = ptr b$). Returns FF (True) or 0 (False)
			push hl
			push de
			call __STRCMP
			pop de
			pop hl

			jp z, __FREE_STR ; Returns 0 if A == B

			dec a		; Returns 0 if A == 1 => a$ > b$
			;jp z, __FREE_STR

			;inc a		; A = FE now (-2). Set it to FF and return
			jp __FREE_STR


__STRLE:	; Compares a$ <= b$ (HL = ptr a$, DE = ptr b$). Returns FF (True) or 0 (False)
			push hl
			push de
			call __STRCMP
			pop de
			pop hl

			dec a		; Returns 0 if A == 1 => a$ < b$
			;jp z, __FREE_STR

			;ld a, 0FFh	; A = FE now (-2). Set it to FF and return
			jp __FREE_STR


__STRGT:	; Compares a$ > b$ (HL = ptr a$, DE = ptr b$). Returns FF (True) or 0 (False)
			push hl
			push de
			call __STRCMP
			pop de
			pop hl

			jp z, __FREE_STR		; Returns 0 if A == B

			inc a		; Returns 0 if A == -1 => a$ < b$
			;jp z, __FREE_STR		; Returns 0 if A == B

			;ld a, 0FFh	; A = FE now (-2). Set it to FF and return
			jp __FREE_STR


__STRGE:	; Compares a$ >= b$ (HL = ptr a$, DE = ptr b$). Returns FF (True) or 0 (False)
			push hl
			push de
			call __STRCMP
			pop de
			pop hl

			inc a		; Returns 0 if A == -1 => a$ < b$
			;jr z, __FREE_STR

			;ld a, 0FFh	; A = FE now (-2). Set it to FF and return

__FREE_STR: ; This exit point will test A' for bits 0 and 1
				; If bit 0 is 1 => Free memory from HL pointer
				; If bit 1 is 1 => Free memory from DE pointer
				; Finally recovers A, to return the result
			PROC

			LOCAL __FREE_STR2
			LOCAL __FREE_END

			ex af, af'
			bit 0, a
			jr z, __FREE_STR2

			push af
			push de
			call __MEM_FREE
			pop de
			pop af

__FREE_STR2:
			bit 1, a
			jr z, __FREE_END

			ex de, hl
			call __MEM_FREE

__FREE_END:
			ex af, af'
			ret

			ENDP

#line 3084 "ZXTelnet.zxbas"

#line 1 "strslice.asm"

	; String slicing library
	; HL = Str pointer
	; DE = String start
	; BC = String character end
	; A register => 0 => the HL pointer wont' be freed from the HEAP
	; e.g. a$(5 TO 10) => HL = a$; DE = 5; BC = 10

	; This implements a$(X to Y) being X and Y first and
	; last characters respectively. If X > Y, NULL is returned

	; Otherwise returns a pointer to a$ FROM X to Y (starting from 0)
	; if Y > len(a$), then a$ will be padded with spaces (reallocating
	; it in dynamic memory if needed). Returns pointer (HL) to resulting
	; string. NULL (0) if no memory for padding.
	;





__STRSLICE:			; Callee entry
		pop hl			; Return ADDRESS
		pop bc			; Last char pos
		pop de			; 1st char pos
		ex (sp), hl		; CALLEE. -> String start

__STRSLICE_FAST:	; __FASTCALL__ Entry
		PROC

		LOCAL __CONT
		LOCAL __EMPTY
		LOCAL __FREE_ON_EXIT

		push hl			; Stores original HL pointer to be recovered on exit
		ex af, af'		; Saves A register for later

		push hl
		call __STRLEN
		inc bc			; Last character position + 1 (string starts from 0)
		or a
		sbc hl, bc		; Compares length with last char position
		jr nc, __CONT	; If Carry => We must copy to end of string
		add hl, bc		; Restore back original LEN(a$) in HL
		ld b, h
		ld c, l			; Copy to the end of str
		ccf				; Clears Carry flag for next subtraction

__CONT:
		ld h, b
		ld l, c			; HL = Last char position to copy (1 for char 0, 2 for char 1, etc)
		sbc hl, de		; HL = LEN(a$) - DE => Number of chars to copy
		jr z, __EMPTY	; 0 Chars to copy => Return HL = 0 (NULL STR)
		jr c, __EMPTY	; If Carry => Nothing to return (NULL STR)

		ld b, h
		ld c, l			; BC = Number of chars to copy
		inc bc
		inc bc			; +2 bytes for string length number

		push bc
		push de
		call __MEM_ALLOC
		pop de
		pop bc
		ld a, h
		or l
		jr z, __EMPTY	; Return if NULL (no memory)

		dec bc
		dec bc			; Number of chars to copy (Len of slice)

		ld (hl), c
		inc hl
		ld (hl), b
		inc hl			; Stores new string length

		ex (sp), hl		; Pointer to A$ now in HL; Pointer to new string chars in Stack
		inc hl
		inc hl			; Skip string length
		add hl, de		; Were to start from A$
		pop de			; Start of new string chars
		push de			; Stores it again
		ldir			; Copies BC chars
		pop de
		dec de
		dec de			; Points to String LEN start
		ex de, hl		; Returns it in HL
		jr __FREE_ON_EXIT

__EMPTY:			; Return NULL (empty) string
		pop hl
		ld hl, 0		; Return NULL


__FREE_ON_EXIT:
		ex af, af'		; Recover original A register
		ex (sp), hl		; Original HL pointer

		or a
		call nz, __MEM_FREE

		pop hl			; Recover result
		ret

		ENDP

#line 3086 "ZXTelnet.zxbas"
#line 1 "u32tofreg.asm"


__I8TOFREG:
		ld l, a
		rlca
		sbc a, a	; A = SGN(A)
		ld h, a
		ld e, a
		ld d, a

__I32TOFREG:	; Converts a 32bit signed integer (stored in DEHL)
					; to a Floating Point Number returned in (A ED CB)

		ld a, d
		or a		; Test sign

		jp p, __U32TOFREG	; It was positive, proceed as 32bit unsigned

		call __NEG32		; Convert it to positive
		call __U32TOFREG	; Convert it to Floating point

		set 7, e			; Put the sign bit (negative) in the 31bit of mantissa
		ret

__U8TOFREG:
					; Converts an unsigned 8 bit (A) to Floating point
		ld l, a
		ld h, 0
		ld e, h
		ld d, h

__U32TOFREG:	; Converts an unsigned 32 bit integer (DEHL)
					; to a Floating point number returned in A ED CB

	    PROC

	    LOCAL __U32TOFREG_END

		ld a, d
		or e
		or h
		or l
	    ld b, d
		ld c, e		; Returns 00 0000 0000 if ZERO
		ret z

		push de
		push hl

		exx
		pop de  ; Loads integer into B'C' D'E'
		pop bc
		exx

		ld l, 128	; Exponent
		ld bc, 0	; DEBC = 0
		ld d, b
		ld e, c

__U32TOFREG_LOOP: ; Also an entry point for __F16TOFREG
		exx
		ld a, d 	; B'C'D'E' == 0 ?
		or e
		or b
		or c
		jp z, __U32TOFREG_END	; We are done

		srl b ; Shift B'C' D'E' >> 1, output bit stays in Carry
		rr c
		rr d
		rr e
		exx

		rr e ; Shift EDCB >> 1, inserting the carry on the left
		rr d
		rr c
		rr b

		inc l	; Increment exponent
		jp __U32TOFREG_LOOP


__U32TOFREG_END:
		exx
	    ld a, l     ; Puts the exponent in a
		res 7, e	; Sets the sign bit to 0 (positive)

		ret
	    ENDP

#line 3087 "ZXTelnet.zxbas"
#line 1 "val.asm"





VAL: ; Computes VAL(a$) using ROM FP-CALC
		 ; HL = address of a$
		 ; Returns FP number in C ED LH registers
		 ; A Register = 1 => Free a$ on return

		PROC

		LOCAL STK_STO_S
		LOCAL __RET_ZERO
		LOCAL ERR_SP
		LOCAL STKBOT
		LOCAL RECLAIM1
	    LOCAL CH_ADD
		LOCAL __VAL_ERROR
		LOCAL __VAL_EMPTY
	    LOCAL SET_MIN

	RECLAIM1	EQU 6629
	STKBOT		EQU 23651
	ERR_SP		EQU 23613
	CH_ADD      EQU 23645
	STK_STO_S	EQU	2AB2h
	SET_MIN     EQU 16B0h

	    ld d, a ; Preserves A register in DE
		ld a, h
		or l
		jr z, __RET_ZERO ; NULL STRING => Return 0

	    push de ; Saves A Register (now in D)
		push hl	; Not null string. Save its address for later

		ld c, (hl)
		inc hl
		ld b, (hl)
		inc hl

		ld a, b
		or c
		jr z, __VAL_EMPTY ; Jumps VAL_EMPTY on empty string

		ex de, hl ; DE = String start

	    ld hl, (CH_ADD)
	    push hl

		ld hl, (STKBOT)
		push hl

		ld hl, (ERR_SP)
		push hl

	    ;; Now put our error handler on ERR_SP
		ld hl, __VAL_ERROR
		push hl
		ld hl, 0
		add hl, sp
		ld (ERR_SP), hl

		call STK_STO_S ; Enter it on the stack

		ld b, 1Dh ; "VAL"
		rst 28h	; ROM CALC
		defb 1Dh ; VAL
		defb 38h ; END CALC

		pop hl 	; Discards our current error handler
		pop hl
		ld (ERR_SP), hl	; Restores ERR_SP

		pop de	         ; old STKBOT
		ld hl, (STKBOT)  ; current SKTBOT
		call	RECLAIM1 ; Recover unused space

	    pop hl  ; Discards old CH_ADD value
		pop hl 	; String pointer
		pop af	; Deletion flag
		or a
		call nz, __MEM_FREE	; Frees string content before returning

	    ld a, ERROR_Ok      ; Sets OK in the result
	    ld (ERR_NR), a

		jp __FPSTACK_POP	; Recovers result and return from there

__VAL_ERROR:	; Jumps here on ERROR
		pop hl
		ld (ERR_SP), hl ; Restores ERR_SP

		ld hl, (STKBOT)  ; current SKTBOT
		pop de	; old STKBOT
	    pop hl
	    ld (CH_ADD), hl  ; Recovers old CH_ADD

	    call 16B0h       ; Resets temporary areas after an error

__VAL_EMPTY:	; Jumps here on empty string
		pop hl      ; Recovers initial string address
	pop af      ; String flag: If not 0 => it's temporary
		or a
		call nz, __MEM_FREE ; Frees "" string

__RET_ZERO:	; Returns 0 Floating point on error
		ld a, ERROR_Ok
		ld (ERR_NR), a

		xor a
		ld b, a
		ld c, a
		ld d, b
		ld e, c
		ret

		ENDP

#line 3088 "ZXTelnet.zxbas"

ZXBASIC_USER_DATA:
	_input40_LastK EQU 23560
_op:
	DEFB 00
_outBuffer:
	DEFB 00, 00
_status:
	DEFB 00
_lastKey:
	DEFB 00, 00
_mLoop:
	DEFB 00, 00
ZXBASIC_MEM_HEAP:
	; Defines DATA END
ZXBASIC_USER_DATA_END EQU ZXBASIC_MEM_HEAP + ZXBASIC_HEAP_SIZE
	; Defines USER DATA Length in bytes
ZXBASIC_USER_DATA_LEN EQU ZXBASIC_USER_DATA_END - ZXBASIC_USER_DATA
	END
